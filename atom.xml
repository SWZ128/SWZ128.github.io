<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>麟子的小站</title>
  
  
  <link href="https://swz128.top/atom.xml" rel="self"/>
  
  <link href="https://swz128.top/"/>
  <updated>2021-09-30T16:00:00.000Z</updated>
  <id>https://swz128.top/</id>
  
  <author>
    <name>麟子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>获取 半次元(https://bcy.net/) 无水印原图</title>
    <link href="https://swz128.top/post/BCY.html"/>
    <id>https://swz128.top/post/BCY.html</id>
    <published>2021-09-30T16:00:00.000Z</published>
    <updated>2021-09-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BCY原图"><a href="#BCY原图" class="headerlink" title="BCY原图"></a>BCY原图</h1><p>用于获取<a href="https://bcy.net/">半次元</a>无水印原图的Tampermonkey脚本</p><p>因为一些原因需要下载半次元的原图，用了一些其他人写的脚本，发现有些地方不满足需求，于是参考前辈们的作品写了一个脚本。在此开源分享：</p><p>GitHub: <a href="https://github.com/SWZ128/BCY">https://github.com/SWZ128/BCY</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>在浏览器中安装油猴插件<br><a href="https://www.tampermonkey.net/">https://www.tampermonkey.net/</a></li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Tampermonkey 是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome, Microsoft Edge, Safari, Opera Next, 和 Firefox。</p></blockquote><ul><li>从 Greasy Fork 中安装本脚本<br><a href="https://greasyfork.org/zh-CN/scripts/434023">https://greasyfork.org/zh-CN/scripts/434023</a></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>启用该脚本后，在图片下方会出现一个「查看原图」的超链接，点击可打开查看相应图片的无水印原图。</p><p>原图 <strong>另存为</strong> 之后，文件名后缀为 <strong>xxx.image</strong> ，需要重名名为 <strong>xxx.jpg</strong> 。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><ul><li><p>半次元获取原图</p><ul><li>插件地址： <a href="https://greasyfork.org/zh-CN/scripts/390830">https://greasyfork.org/zh-CN/scripts/390830</a></li></ul></li><li><p>显示半次元（bcy.net）图片的大图url（下载辅助）</p><ul><li>插件地址： <a href="https://greasyfork.org/zh-CN/scripts/23336">https://greasyfork.org/zh-CN/scripts/23336</a></li></ul></li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT License</p><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><ul><li>作者：麟子</li><li>地址：<a href="https://swz128.top/post/BCY">https://swz128.top/post/BCY</a></li><li>协议：<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 欢迎转载，务必注明出处</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BCY原图&quot;&gt;&lt;a href=&quot;#BCY原图&quot; class=&quot;headerlink&quot; title=&quot;BCY原图&quot;&gt;&lt;/a&gt;BCY原图&lt;/h1&gt;&lt;p&gt;用于获取&lt;a href=&quot;https://bcy.net/&quot;&gt;半次元&lt;/a&gt;无水印原图的Tampermonkey脚本</summary>
      
    
    
    
    <category term="项目" scheme="https://swz128.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="油猴" scheme="https://swz128.top/tags/%E6%B2%B9%E7%8C%B4/"/>
    
    <category term="脚本" scheme="https://swz128.top/tags/%E8%84%9A%E6%9C%AC/"/>
    
    <category term="Chrome" scheme="https://swz128.top/tags/Chrome/"/>
    
    <category term="Firefox" scheme="https://swz128.top/tags/Firefox/"/>
    
    <category term="Tampermonkey" scheme="https://swz128.top/tags/Tampermonkey/"/>
    
    <category term="半次元" scheme="https://swz128.top/tags/%E5%8D%8A%E6%AC%A1%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>基于容器（docker）的 WRF模式 简易快速部署方案</title>
    <link href="https://swz128.top/post/easy-wrf.html"/>
    <id>https://swz128.top/post/easy-wrf.html</id>
    <published>2020-09-30T16:00:00.000Z</published>
    <updated>2020-09-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.swz128.top/EASY-WRF_File/logo.png" alt="logo"></p><h1 id="Easy-WRF"><a href="#Easy-WRF" class="headerlink" title="Easy-WRF"></a>Easy-WRF</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>WRF（Weather Research and Forecasting Model）模式是由NCEP，NCAR等科研机构中心着手开发的一种统一的中尺度天气预报模式。<br>WRF模式系统具有的可移植，易维护，可扩充，高效率，方便等特点，使其成为改进从云尺度到各种不同天气尺度的重要天气特征预报精度的工具。</p></blockquote><p><strong>但是WRF模式的安装对于初学者来说有一定的困难，因此为了帮助初学者在电脑上快速部署安装WRF模式，就有了该项目，Easy-WRF。</strong></p><p>项目地址：<br>GitHub: <a href="https://github.com/SWZ128/easy-wrf">https://github.com/SWZ128/easy-wrf</a></p><p>本项目是单节点建模运行的容器化WRF，主要用于教学和培训示例，本人不是气象相关专业，谬误在所难免，望海涵。</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>WPS + WRF（version 3.7.1）</li><li>简易部署（docker）</li><li>优雅易用（Oh-my-zsh）</li><li>精简小巧（镜像1.6GB左右）</li><li>国内部署简易</li></ul><h2 id="Installation-amp-Usage"><a href="#Installation-amp-Usage" class="headerlink" title="Installation &amp; Usage"></a>Installation &amp; Usage</h2><h3 id="方案1、使用-docker-pull-拉取（推荐）"><a href="#方案1、使用-docker-pull-拉取（推荐）" class="headerlink" title="方案1、使用 docker pull 拉取（推荐）"></a>方案1、使用 docker pull 拉取（推荐）</h3><p>确保已经安装docker，如果还没有，<a href="https://www.runoob.com/docker/centos-docker-install.html">点击我</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull swz128&#x2F;easy-wrf</code></pre><p>检查镜像是否拉取成功</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker images</code></pre><p>得到类似下方的输出</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">REPOSITORY        TAG       IMAGE ID       CREATED             SIZEswz128&#x2F;easy-wrf   latest    2c04b5c62a0b   About an hour ago   1.6GB</code></pre><p>run</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -v 需要挂载的本地目录:容器中的目录 -it --name test_001 swz128&#x2F;easy-wrf</code></pre><p>例如这样（请将路径修改为自己的）</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -v &#x2F;Users&#x2F;mac&#x2F;wrf&#x2F;wrf-data:&#x2F;root&#x2F;wrf-data -it --name test_001 swz128&#x2F;easy-wrf</code></pre><p>现在就可以愉快地学习和使用了</p><p>停止容器</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker stop test_001</code></pre><p>当退出并停止容器后，可以使用如下命令再次进入</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker start test_001docker exec -it test_001 &#x2F;bin&#x2F;zsh</code></pre><h3 id="方案2、使用-docker-build"><a href="#方案2、使用-docker-build" class="headerlink" title="方案2、使用 docker build"></a>方案2、使用 docker build</h3><p>将项目克隆到本地</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git clone https:&#x2F;&#x2F;github.com&#x2F;swz128&#x2F;easy-wrf.gitcd easy-wrf&#x2F;</code></pre><p>Build</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker build -t esay-wrf .</code></pre><h2 id="Support"><a href="#Support" class="headerlink" title="Support"></a>Support</h2><ul><li><a href="https://www2.mmm.ucar.edu/wrf/users/docs/user_guide_V3/user_guide_V3.8/contents.html">官方文档</a></li><li><a href="https://github.com/wrf-model/WRF/">官方GitHub</a></li><li><a href="http://bbs.06climate.com/">气象家园论坛</a></li></ul><h2 id="Acknowledgment"><a href="#Acknowledgment" class="headerlink" title="Acknowledgment"></a>Acknowledgment</h2><ul><li><a href="https://github.com/NCAR/container-wrf">container-wrf</a></li><li><a href="https://github.com/wrf-model/WRF">WRF</a></li><li><a href="https://github.com/davegill/wrf-coop">wrf-coop</a></li><li><a href="https://www2.mmm.ucar.edu/wrf/src/">wrf-src</a></li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT License</p><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><ul><li>作者：麟子</li><li>地址：<a href="https://swz128.top/post/easy-wrf">https://swz128.top/post/easy-wrf</a></li><li>协议：<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 欢迎转载，务必注明出处</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.swz128.top/EASY-WRF_File/logo.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Easy-WRF&quot;&gt;&lt;a href=&quot;#Easy-WRF&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="项目" scheme="https://swz128.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="docker" scheme="https://swz128.top/tags/docker/"/>
    
    <category term="WRF模式" scheme="https://swz128.top/tags/WRF%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="安装" scheme="https://swz128.top/tags/%E5%AE%89%E8%A3%85/"/>
    
    <category term="easy-wrf" scheme="https://swz128.top/tags/easy-wrf/"/>
    
  </entry>
  
  <entry>
    <title>Dart 语言简易入门</title>
    <link href="https://swz128.top/post/Dart.html"/>
    <id>https://swz128.top/post/Dart.html</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2019-12-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dart-学习总结"><a href="#Dart-学习总结" class="headerlink" title="Dart 学习总结"></a>Dart 学习总结</h1><p><strong>本文大量学习借鉴了 「AWeiLoveAndroid」、 「name不是null」 与 「彡廿」 的博文和 「Flutter中文网」 的入门指南，在此表示感谢，被引用文章链接见文末</strong></p><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h2><p>可以用C\C++风格的方式声明变量，如<strong>int, bool, String</strong>等，也可以用<strong>var</strong>或者<strong>dynamic</strong>来声明，Dart会自动推断类型。</p><p>没有赋初值的变量都会有默认值<strong>null</strong>。</p><p><strong>final</strong>要求变量只能初始化一次，并不要求赋的值一定是编译时常量，可以是常量也可以不是。而<strong>const</strong>要求在声明时初始化，并且赋值必需为编译时常量。</p><p>Dart有如下几种内建的数据类型：</p><ul><li>numbers (var, num, int, double)</li><li>strings (var, String)</li><li>booleans (var, bool)</li><li>lists (或者是arrays)</li><li>maps (类似Python里的字典)</li><li>runes（UTF-32字符集的字符）</li><li>symbols</li></ul><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; numbers  var a &#x3D; 0;  int b &#x3D; 1;  double c &#x3D; 0.1;  &#x2F;&#x2F; strings  var s1 &#x3D; &#39;hello&#39;;  String s2 &#x3D; &quot;world&quot;;  &#x2F;&#x2F; booleans  var real &#x3D; true;  bool isReal &#x3D; false;  &#x2F;&#x2F; lists  var arr &#x3D; [1, 2, 3, 4, 5];  List&lt;String&gt; arr2 &#x3D; [&#39;hello&#39;, &#39;world&#39;, &quot;123&quot;, &quot;456&quot;];  List&lt;dynamic&gt; arr3 &#x3D; [1, true, &#39;haha&#39;, 1.0];  &#x2F;&#x2F; maps  var map &#x3D; new Map();  map[&#39;name&#39;] &#x3D; &#39;zhangsan&#39;;  map[&#39;age&#39;] &#x3D; 10;  Map m &#x3D; new Map();  m[&#39;a&#39;] &#x3D; &#39;a&#39;;  &#x2F;&#x2F;runes，Dart 中 使用runes 来获取UTF-32字符集的字符。String的 codeUnitAt and codeUnit属性可以获取UTF-16字符集的字符  var clapping &#x3D; &#39;\u&#123;1f44f&#125;&#39;;  print(clapping); &#x2F;&#x2F; 打印的是拍手emoji的表情  &#x2F;&#x2F; symbols  print(#s &#x3D;&#x3D; new Symbol(&quot;s&quot;)); &#x2F;&#x2F; true&#125;</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>所有的函数都有返回值，如果没有指定<strong>return</strong>语句，那么该函数的返回值为<strong>null</strong>。</p><p>Dart是一个面向对象的编程语言，所以即使是函数也是一个对象，也有一种类型<strong>Function</strong>，这就意味着函数可以赋值给某个变量或者作为参数传给另外的函数。虽然Dart推荐你给函数加上返回值，但是不加返回值的函数同样可以正常工作，另外你还可以用 <strong>=&gt;</strong> 代替 <strong>return</strong> 语句，比如下面的代码：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 声明返回值int add(int a, int b) &#123;  return a + b;&#125;&#x2F;&#x2F; 不声明返回值add2(int a, int b) &#123;  return a + b;&#125;&#x2F;&#x2F; &#x3D;&gt;是return语句的简写add3(a, b) &#x3D;&gt; a + b;main() &#123;  print(add(1, 2)); &#x2F;&#x2F; 3  print(add2(2, 3)); &#x2F;&#x2F; 5  print(add3(1, 2)); &#x2F;&#x2F; 3&#125;</code></pre><h3 id="可选的命名参数"><a href="#可选的命名参数" class="headerlink" title="可选的命名参数"></a>可选的命名参数</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">sayHello(String name) &#123;  print(&quot;hello, my name is $name&quot;);&#125;sayHello2(&#123;String name&#125;) &#123;  print(&quot;hello, myname is $name&quot;);&#125;sayHello3(&#123;name: String&#125;) &#123;  print(&quot;hello, my name is $name&quot;);&#125;main() &#123;  &#x2F;&#x2F; 打印 hello, my name is zhangsan  sayHello(&#39;zhangsan&#39;);  &#x2F;&#x2F; 打印 hello, my name is wangwu  sayHello2(name: &#39;wangwu&#39;);  sayHello3(name: &#39;wangwu&#39;);&#125;</code></pre><p>可以看到，定义命名参数时，你可以以 <strong>{type paramName}</strong> 或者 <strong>{paramName: type}</strong> 两种方式声明参数，而调用命名参数时，需要以 <strong>funcName(paramName: paramValue)</strong> 的形式调用。</p><p>命名参数的参数并<strong>不是必须</strong>的，所以上面的代码中，如果调用 <strong>sayHello()</strong> 不带任何参数，也是可以的，只不过最后打印出来的结果是：hello, my name is null，在Flutter开发中，你可以使用 <strong>@required</strong> 注解来标识一个命名参数，这代表该参数是必须的，你不传则会报错，比如下面的代码：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">const Scrollbar(&#123;Key key, @required Widget child&#125;)</code></pre><h3 id="可选的位置参数"><a href="#可选的位置参数" class="headerlink" title="可选的位置参数"></a>可选的位置参数</h3><p>使用中括号 <strong>[]</strong> 括起来的参数是函数的位置参数，代表该参数可传可不传，位置参数只能放在函数的参数列表的最后面，如下代码所示：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">sayHello(String name, int age, [String hobby]) &#123; &#x2F;&#x2F; 位置参数可以有多个，比如[String a, int b]  StringBuffer sb &#x3D; new StringBuffer();  sb.write(&quot;hello, this is $name and I am $age years old&quot;);  if (hobby !&#x3D; null) &#123;    sb.write(&quot;, my hobby is $hobby&quot;);  &#125;  print(sb.toString());&#125;main() &#123;  &#x2F;&#x2F; hello, this is zhangsan and I am 20 years old  sayHello(&quot;zhangsan&quot;, 20);  &#x2F;&#x2F; hello, this is zhangsan and I am 20 years old, my hobby is play football  sayHello(&quot;zhangsan&quot;, 20, &quot;play football&quot;);&#125;</code></pre><p><strong>注意，不能同时使用可选的位置参数和可选的命名参数。</strong></p><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 命名参数的默认值int add(&#123;int a, int b &#x3D; 3&#125;) &#123; &#x2F;&#x2F; 不能写成：int add(&#123;a: int, b: int &#x3D; 3&#125;)    return a + b;&#125;&#x2F;&#x2F; 位置参数的默认值int sum(int a, int b, [int c &#x3D; 3]) &#123;  return a + b + c;&#125;main() &#123;  print(add(a: 1)); &#x2F;&#x2F;4  print(sum(1,2)); &#x2F;&#x2F;6&#125;</code></pre><h3 id="函数作为变量"><a href="#函数作为变量" class="headerlink" title="函数作为变量"></a>函数作为变量</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">var say &#x3D; (str)&#123;  print(str);&#125;;main()&#123;  say(&quot;hi world&quot;);&#125;</code></pre><h3 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">List list &#x3D; [10, 7, 23];list.forEach((item) &#123;  print(&#39;$item&#39;);&#125;);</code></pre><p>这里面的参数是一个函数 <strong>(){}</strong> (省略函数名)。<strong>forEach</strong> 源码是：<strong>forEach (void f(E element))</strong>,它的参数是一个函数。以上语句可以简写成：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">list.forEach((item) &#x3D;&gt; print(&#39;$item&#39;));</code></pre><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">void execute(var callback) &#123;    callback();&#125;main() &#123;  execute(() &#x3D;&gt; print(&quot;xxx&quot;)); &#x2F;&#x2F;xxx&#125;</code></pre><h3 id="函数别名"><a href="#函数别名" class="headerlink" title="函数别名"></a>函数别名</h3><p><strong>typedef</strong>,会保留类型信息。</p><p>以下代码，它不使用<strong>typedef</strong>：我们可以看到funs是一个函数，它是<strong>Function</strong>类型。</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Demo &#123;  Function funs;  Demo (int f(Object a, Object b)) &#123;    funs &#x3D; f;  &#125;&#125;int test(Object a, Object b) &#x3D;&gt; 0;void main() &#123;  Demo demo &#x3D; Demo(test);  &#x2F;&#x2F; funs是一个函数，但它是哪一种类型的函数?  print(demo.funs is Function); &#x2F;&#x2F; true&#125;</code></pre><p>可以使用<strong>typedef</strong>给函数取个别名。接下来使用<strong>typedef</strong>改造一下。</p><p>1.给<strong>Function</strong>取一个别名叫做<strong>TypedefFuns</strong></p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">typedef TypedefFuns &#x3D; int Function(Object a, Object b);</code></pre><p>2.<strong>Demo</strong>类里的构造方法使用这个别名</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Demo &#123;  TypedefFuns funs;  Demo(this.funs);&#125;</code></pre><p>3.使用<strong>Demo</strong>类，传入一个函数。这里给<strong>Demo</strong>类传入了一个函数<strong>test</strong>。判断<strong>demo.funs</strong>属于哪一种类型。</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">int test(Object a, Object b) &#x3D;&gt; 0;void main() &#123;  Demo demo &#x3D; Demo(test);  print(demo.funs is Function); &#x2F;&#x2F; true  print(demo.funs is Demo); &#x2F;&#x2F; false&#125;</code></pre><p><strong>typedef</strong>还可以这样使用</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">typedef TypedefFuns2&lt;T&gt; &#x3D; int Function(T a, T b);int test2(int a, int b) &#x3D;&gt; a - b;void main() &#123;  print(test2 is TypedefFuns2&lt;int&gt;); &#x2F;&#x2F; True&#125;</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; 与Java相同的运算符操作  int a &#x3D; 1;  ++a;  a++;  var b &#x3D; 1;  print(a &#x3D;&#x3D; b);  &#x2F;&#x2F; false  print(a * b); &#x2F;&#x2F; 3  bool real &#x3D; false;  real ? print(&#39;real&#39;) : print(&#39;not real&#39;); &#x2F;&#x2F; not real  print(real &amp;&amp; a &#x3D;&#x3D; b); &#x2F;&#x2F; false  print(real || a &#x3D;&#x3D; 3); &#x2F;&#x2F; true  print(a !&#x3D; 2); &#x2F;&#x2F; true  print(a &lt;&#x3D; b); &#x2F;&#x2F; false  var c &#x3D; 9;  c +&#x3D; 10;  print(&quot;c &#x3D; $c&quot;); &#x2F;&#x2F; c &#x3D; 19  print(1&lt;&lt;2); &#x2F;&#x2F; 4  &#x2F;&#x2F; 与Java不太一样的运算符操作  &#x2F;&#x2F; is运算符用于判断一个变量是不是某个类型的数据  &#x2F;&#x2F; is!则是判断变量不是某个类型的数据  var s &#x3D; &quot;hello&quot;;  print(s is String); &#x2F;&#x2F; true  var num &#x3D; 6;  print(num is! String); &#x2F;&#x2F; true  &#x2F;&#x2F; ~&#x2F;才是取整运算符，如果使用&#x2F;则是除法运算，不取整  int k &#x3D; 1;  int j &#x3D; 2;  print(k &#x2F; j); &#x2F;&#x2F; 0.5  print(k ~&#x2F; j); &#x2F;&#x2F; 0  &#x2F;&#x2F; as运算符类似于Java中的cast操作，将一个对象强制类型转换  (emp as Person).teach();  &#x2F;&#x2F; ??&#x3D;运算符 如果 ??&#x3D; 运算符前面的变量为null，则赋值，否则不赋值  var param1 &#x3D; &quot;hello&quot;, param2 &#x3D; null;  param1 ??&#x3D; &quot;world&quot;;  param2 ??&#x3D; &quot;world&quot;;  print(&quot;param1 &#x3D; $param1&quot;); &#x2F;&#x2F; param1 &#x3D; hello  print(&quot;param2 &#x3D; $param2&quot;); &#x2F;&#x2F; param2 &#x3D; world    &#x2F;&#x2F; ?.运算符  var str1 &#x3D; &quot;hello world&quot;;  var str2 &#x3D; null;  print(str1?.length); &#x2F;&#x2F; 11  print(str2?.length); &#x2F;&#x2F; null   print(str2.length); &#x2F;&#x2F; 报错&#125;</code></pre><h3 id="运算符（级联操作）"><a href="#运算符（级联操作）" class="headerlink" title="..运算符（级联操作）"></a>..运算符（级联操作）</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  eat() &#123;    print(&quot;I am eating...&quot;);  &#125;  sleep() &#123;    print(&quot;I am sleeping...&quot;);  &#125;  study() &#123;    print(&quot;I am studying...&quot;);  &#125;&#125;main() &#123;  &#x2F;&#x2F; 依次打印  &#x2F;&#x2F;  I am eating...  &#x2F;&#x2F;  I am sleeping...  &#x2F;&#x2F;  I am studying...  new Person()..eat()      ..sleep()      ..study();&#125;</code></pre><p>可以看到，使用..调用某个对象的方法（或者成员变量）时，返回值是这个对象本身，所以你可以接着使用..调用这个对象的其他方法，这不就类似于Java中的建造者模式，每次build某个属性时，都返回一个<strong>this</strong>对象。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  &#x2F;&#x2F; if else语句  int score &#x3D; 80;  if (score &lt; 60) &#123;    print(&quot;so bad!&quot;);  &#125; else if (score &gt;&#x3D; 60 &amp;&amp; score &lt; 80) &#123;    print(&quot;just so so!&quot;);  &#125; else if (score &gt;&#x3D; 80) &#123;    print(&quot;good job!&quot;);  &#125;  &#x2F;&#x2F; switch语句  String a &#x3D; &quot;hello&quot;;  &#x2F;&#x2F; case语句中的数据类型必须是跟switch中的类型一致  switch (a) &#123;    case &quot;hello&quot;:      print(&quot;haha&quot;);      break;    case &quot;world&quot;:      print(&quot;heihei&quot;);      break;    default:      print(&quot;WTF&quot;);  &#125;  &#x2F;&#x2F; for语句  List&lt;String&gt; list &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];  for (int i &#x3D; 0; i &lt; list.length; i++) &#123;    print(list[i]);  &#125;  for (var i in list) &#123;    print(i);  &#125;  &#x2F;&#x2F; 这里的箭头函数参数必须用圆括号扩起来  list.forEach((item) &#x3D;&gt; print(item)); &#x2F;&#x2F;匿名函数  &#x2F;&#x2F; while语句  int start &#x3D; 1;  int sum &#x3D; 0;  while (start &lt;&#x3D; 100) &#123;    sum +&#x3D; start;    start++;  &#125;  print(sum);  &#x2F;&#x2F; try catch语句  try &#123;    print(1 ~&#x2F; 0);  &#125; catch (e) &#123;    &#x2F;&#x2F; IntegerDivisionByZeroException    print(e);  &#125;  try &#123;    1 ~&#x2F; 0;  &#125; on IntegerDivisionByZeroException &#123; &#x2F;&#x2F; 捕获指定类型的异常    print(&quot;error&quot;); &#x2F;&#x2F; 打印出error  &#125; finally &#123;    print(&quot;over&quot;); &#x2F;&#x2F; 打印出over  &#125;&#125;</code></pre><h3 id="assert（断言）"><a href="#assert（断言）" class="headerlink" title="assert（断言）"></a>assert（断言）</h3><p>断言的作用是：如果表达式的求值结果不满足需要，则打断代码的执行。可以要将提示消息附加到断言，添加一个字符串作为第二个参数。</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">void main()&#123;    String urlString &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;;    assert(urlString.startsWith(&#39;https&#39;), &#39;URL ($urlString) should start with &quot;https&quot;.&#39;);    &#x2F;&#x2F; Failed assertion: &#39;urlString.startsWith(&#39;https&#39;)&#39;: URL (http:&#x2F;&#x2F;www.baidu.com) should start with &quot;https&quot;    &#x2F;&#x2F; 当urlString不是以https开头时，代码的执行会被打断    &#x2F;&#x2F; 当urlString是以https开头时，代码会继续执行&#125;</code></pre><p>传入<strong>assert</strong>的参数，可以是任意表达式或者方法，只要返回值是<strong>bool</strong>就可以，当断言失败时（返回<strong>false</strong>），会抛出<strong>AssertionError</strong>异常。</p><p><strong>注意:断言只有在检查模式下运行有效，在生产模式下是不会运行的。</strong></p><h2 id="类（Class）"><a href="#类（Class）" class="headerlink" title="类（Class）"></a>类（Class）</h2><h3 id="类的定义与构造方法"><a href="#类的定义与构造方法" class="headerlink" title="类的定义与构造方法"></a>类的定义与构造方法</h3><p>Dart中的类没有访问控制，所以你不需要用<strong>private, protected, public</strong>等修饰成员变量或成员函数，一个简单的类如下代码所示：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Person &#123;  String name;  int age;  String gender;  Person(this.name, this.age, this.gender);  sayHello() &#123;    print(&quot;hello, this is $name, I am $age years old, I am a $gender&quot;);  &#125;&#125;</code></pre><p>上面的<strong>Person</strong>类中有3个成员变量，一个构造方法和一个成员方法，看起来比较奇怪的是<strong>Person</strong>的构造方法，里面传入的3个参数都是<strong>this.xxx</strong>，而且没有大括号**{}**包裹的方法体，这种语法是Dart比较独特而简洁的构造方法声明方式，它等同于下面的代码：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">Person(String name, int age, String gender) &#123;    this.name &#x3D; name;    this.age &#x3D; age;    this.gender &#x3D; gender;&#125;</code></pre><p>要调用<strong>Person</strong>类的成员变量或成员方法，可以用下面的代码。</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">var p &#x3D; new Person(&quot;zhangsan&quot;, 20, &quot;male&quot;);p.sayHello(); &#x2F;&#x2F; hello, this is zhangsan, I am 20 years old, I am a malep.age &#x3D; 50;p.gender &#x3D; &quot;female&quot;;p.sayHello(); &#x2F;&#x2F; hello, this is zhangsan, I am 50 years old, I am a female</code></pre><p>类除了有跟类名相同的构造方法外，还可以添加<strong>命名的构造方法</strong>，如下代码所示：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Point &#123;  num x, y;区块中使用列表实例如下  Point(this.x, this.y);  &#x2F;&#x2F; 类的命名构造方法  Point.origin() &#123;    x &#x3D; 0;    y &#x3D; 0;  &#125;&#125;main() &#123;  &#x2F;&#x2F; 调用Point类的命名构造方法origin()  var p &#x3D; new Point.origin();  var p2 &#x3D; new Point(1, 2);&#125;</code></pre><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>类似C/C++风格的初始化列表。</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Test1 &#123;  var x, y;  Test1(var x, var y) : x &#x3D; x, y &#x3D; y &#123;    print(&#39;Test1 有参构造初始化&#39;);  &#125;&#125;</code></pre><p>在实际应用开发中，可以使用<strong>assert</strong>（断言）在初始化列表用来校验输入参数。</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Test1 &#123;  var x, y;  Test1(var x, var y) : assert(x &gt;&#x3D; 0) &#123;    print(&#39;Test1(): ($x, $y)&#39;);  &#125;&#125;</code></pre><p><strong>assert</strong>（断言）的作用：如果表达式求值不满足需要，则打断代码的执行。</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>Dart中使用 <strong>extends</strong> 关键字做类的继承，如果一个类只有命名的构造方法，在继承时需要注意，如下代码：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Human &#123;  String name;  Human.fromJson(Map data) &#123;    print(&quot;Human&#39;s fromJson constructor&quot;);  &#125;&#125;class Man extends Human &#123;  Man.fromJson(Map data) : super.fromJson(data) &#123;    print(&quot;Man&#39;s fromJson constructor&quot;);  &#125;&#125;</code></pre><p>由于<strong>Human</strong>类没有默认构造方法，只有一个命名构造方法<strong>fromJson</strong>，所以在<strong>Man</strong>类继承<strong>Human</strong>类时，需要调用父类的<strong>fromJson</strong>方法做初始化，而且必须使用 <strong>Man.fromJson(Map data) : super.fromJson(data)</strong> 这种写法，而不是像Java那样将 <strong>super</strong> （指向父类）写到花括号中。</p><p>使用 <strong>@override</strong> 注解声明你要重写的函数，在这个函数内部可以使用 <strong>super</strong> 调用重写的这个父类的函数。实现如下：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Test &#123;  void test() &#123;&#x2F;*这里省略方法内部的逻辑操作*&#x2F;&#125;  &#x2F;&#x2F; 其他逻辑&#125;class TestChild extends Test &#123;  @override  &#x2F;&#x2F;@override标注在test()函数上面 表示test()函数是重写父类的。    void test() &#123;      super.test();&#x2F;&#x2F; 调用父类的test()函数      &#x2F;*这里省略方法内部的逻辑操作*&#x2F;    &#125;    &#x2F;&#x2F; 其他逻辑&#125;</code></pre><h3 id="类的成员方法"><a href="#类的成员方法" class="headerlink" title="类的成员方法"></a>类的成员方法</h3><p>一个类的成员方法是一个函数，为这个类提供某些行为。上面的代码中已经有了一些类的成员方法的定义，这些定义方式跟Java很类似，你可以为某个类的成员变量提供<strong>getter/setter</strong>方法，如下代码：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Rectangle &#123;  num left, top, width, height;  &#x2F;&#x2F; 构造方法传入left, top, width, height几个参数  Rectangle(this.left, this.top, this.width, this.height);  &#x2F;&#x2F; right, bottom两个成员变量提供getter&#x2F;setter方法  num get right &#x3D;&gt; left + width;  set right(num value) &#x3D;&gt; left &#x3D; value - width;  num get bottom &#x3D;&gt; top + height;  set bottom(num value) &#x3D;&gt; top &#x3D; value - height;&#125;</code></pre><p><strong>getter</strong>和<strong>setter</strong>是提供对象属性的<strong>读写访问</strong>的特殊方法。所有实例变量都生成一个隐式<strong>getter</strong>方法。<strong>非final</strong>实例变量也会生成隐式<strong>setter</strong>方法。使用<strong>get</strong>和<strong>set</strong>关键字通过实现<strong>getter</strong>和<strong>setter</strong>来创建其他属性。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法：使用<strong>static</strong>关键字修饰的方法，也叫类方法，它不对实例进行操作，因此无权访问<strong>this</strong>。</p><h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><p>使用abstract修饰一个类，则这个类是抽象类，抽象类中可以有抽象方法和非抽象方法，抽象方法没有方法体，需要子类去实现，如下代码：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">abstract class Doer &#123;  &#x2F;&#x2F; 抽象方法，没有方法体，需要子类去实现  void doSomething();  &#x2F;&#x2F; 普通的方法  void greet() &#123;    print(&quot;hello world!&quot;);  &#125;&#125;class EffectiveDoer extends Doer &#123;  &#x2F;&#x2F; 实现了父类的抽象方法  void doSomething() &#123;    print(&quot;I&#39;m doing something...&quot;);  &#125;&#125;</code></pre><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>Dart中有类似于C++中的运算符重载语法，比如下面的代码定义了一个向量类，重载了向量的+ -运算：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class Vector &#123;  num x, y;  Vector(this.x, this.y);  Vector operator +(Vector v) &#x3D;&gt; new Vector(x + v.x, y + v.y);  Vector operator -(Vector v) &#x3D;&gt; new Vector(x - v.x, y - v.y);  printVec() &#123;    print(&quot;x: $x, y: $y&quot;);  &#125;&#125;main() &#123;  Vector v1 &#x3D; new Vector(1, 2);  Vector v2 &#x3D; new Vector(3, 4);  (v1 - v2).printVec(); &#x2F;&#x2F; -2, -2  (v1 + v2).printVec(); &#x2F;&#x2F; 4, 6&#125;</code></pre><p>注意：**!=**不是可重写的运算符。</p><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>使用<strong>enum</strong>关键字声明枚举类型：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">enum Color &#123; red, green, blue &#125;</code></pre><p>枚举中的每个值都有一个<strong>index getter</strong>，它返回枚举声明中值的从零开始的位置。例如，<strong>第一个值具有索引0，第二个值具有索引1</strong>。</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">assert(Color.red.index &#x3D;&#x3D; 0);assert(Color.green.index &#x3D;&#x3D; 1);assert(Color.blue.index &#x3D;&#x3D; 2);</code></pre><p>在实际应用开发中，可以使用<strong>assert</strong>在初始化列表用来校验输入参数。</p><p>要获取枚举中所有值的列表，请使用枚举<strong>values</strong>常量。</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">List&lt;Color&gt; colors &#x3D; Color.values;assert(colors[2] &#x3D;&#x3D; Color.blue);</code></pre><p>可以在 <strong>switch</strong> 语句中使用枚举，如果你不处理所有枚举值，你将收到警告。</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">var aColor &#x3D; Color.blue;switch (aColor) &#123;  case Color.red:    print(&#39;Red&#39;);    break;  case Color.green:    print(&#39;Green&#39;);    break;  default: &#x2F;&#x2F; 你没有这个 你会看到一个警告    print(aColor); &#x2F;&#x2F; &#39;Color.blue&#39;&#125;</code></pre><h3 id="静态成员变量和静态成员方法"><a href="#静态成员变量和静态成员方法" class="headerlink" title="静态成员变量和静态成员方法"></a>静态成员变量和静态成员方法</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 类的静态成员变量和静态成员方法class Cons &#123;  static const name &#x3D; &quot;zhangsan&quot;;  static sayHello() &#123;    print(&quot;hello, this is $&#123;Cons.name&#125;&quot;);  &#125;&#125;main() &#123;  Cons.sayHello(); &#x2F;&#x2F; hello, this is zhangsan  print(Cons.name); &#x2F;&#x2F; zhangsan&#125;</code></pre><h3 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h3><p>mixins是一个重复使用类中代码的方式，比如下面的代码：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">class A &#123;  a() &#123;    print(&quot;A&#39;s a()&quot;);  &#125;&#125;class B &#123;  b() &#123;    print(&quot;B&#39;s b()&quot;);  &#125;&#125;&#x2F;&#x2F; 使用with关键字，表示类C是由类A和类B混合而构成class C &#x3D; A with B;main() &#123;  C c &#x3D; new C();  c.a(); &#x2F;&#x2F; A&#39;s a()  c.b(); &#x2F;&#x2F; B&#39;s b()&#125;</code></pre><h2 id="泛型（Generics）"><a href="#泛型（Generics）" class="headerlink" title="泛型（Generics）"></a>泛型（Generics）</h2><p>正确指定泛型类型会产生更好的生成代码。泛型可以减小代码的复杂度。</p><p>Dart内置的数据类型List就是一个泛型数据类型，你可以往<strong>List</strong>中塞任何你想的数据类型比如整型、字符串、布尔值等。</p><p> 当然，如果您希望列表只包含字符串，则可以将其声明为**List&lt;String&gt;**（字符串列表）。这样一来，工具可以检测到将非字符串分配给列表可能是一个错误。</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">var names &#x3D; List&lt;String&gt;();names.addAll([&#39;Seth&#39;, &#39;Kathy&#39;, &#39;Lars&#39;]);&#x2F;&#x2F; 报错 The argument type &#39;int&#39; can&#39;t be assigned to the parameter type &#39;String&#39;.names.add(42); </code></pre><p>泛型允许你在多种类型之间共享单个接口和实现，同时仍然利用静态分析。你可以创建一个带有类型参数的接口。示例如下：T是一个占位符，你可以将其视为开发人员稍后定义的类型。</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">abstract class Cache&lt;T&gt; &#123;  T getByKey(String key);&#125;</code></pre><h2 id="Dart库（Libraries）"><a href="#Dart库（Libraries）" class="headerlink" title="Dart库（Libraries）"></a>Dart库（Libraries）</h2><p>Dart目前已经有很多的库提供给开发者，许多功能不需要开发者自己去实现，只需要导入对应的包即可，使用<strong>import</strong>语句来导入某个包，比如下面的代码：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;dart:html&#39;;</code></pre><p>如果你想导入自己写的某个代码文件，使用相对路径即可，例如当前有一个<strong>demo.dart</strong>文件，跟该文件同级目录下有个<strong>util.dart</strong>文件，文件代码如下：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; util.dart文件内容int add(int a, int b) &#123;  return a + b;&#125;</code></pre><p>在<strong>demo.dart</strong>文件中如果要引用<strong>util.dart</strong>文件，使用下面的方式导入：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; demo.dartimport &#39;.&#x2F;util.dart&#39;;main() &#123;  print(add(1, 2));&#125;</code></pre><p>你可以使用<strong>as</strong>关键字为导入的某个包设置一个前缀，或者说别名，比如下面的代码：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;package:lib1&#x2F;lib1.dart&#39;;import &#39;package:lib2&#x2F;lib2.dart&#39; as lib2;&#x2F;&#x2F; Uses Element from lib1.Element element1 &#x3D; Element();&#x2F;&#x2F; Uses Element from lib2.lib2.Element element2 &#x3D; lib2.Element();</code></pre><p>你也可以在导入包时使用<strong>show, hide</strong>关键字来导入某个包中的部分功能，比如下面的代码：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; 只导入fooimport &#39;package:lib1&#x2F;lib1.dart&#39; show foo;&#x2F;&#x2F; 导入除了foo的所有其他部分import &#39;package:lib2&#x2F;lib2.dart&#39; hide foo;</code></pre><p>导入包时使用<strong>deferred as</strong>可以让这个包懒加载，懒加载的包只会在该包被使用时得到加载，而不是一开始就加载，比如下面的代码：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">import &#39;package:greetings&#x2F;hello.dart&#39; deferred as hello;</code></pre><h2 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h2><p>Dart类库有非常多的返回Future或者Stream对象的函数。 这些函数被称为异步函数：它们只会在设置好一些耗时操作之后返回，比如像 IO操作。而不是等到这个操作完成。</p><p>async和await关键词支持了异步编程，允许您写出和同步代码很像的异步代码。</p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future与JavaScript中的Promise非常相似，表示一个异步操作的最终完成（或失败）及其结果值的表示。简单来说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。一个Future只会对应一个结果，要么成功，要么失败。</p><p>由于本身功能较多，这里我们只介绍其常用的API及特性。还有，请记住，Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用。</p><h4 id="Future-then"><a href="#Future-then" class="headerlink" title="Future.then"></a>Future.then</h4><p>为了方便示例，在本例中我们使用<strong>Future.delayed</strong>创建了一个延时任务（实际场景会是一个真正的耗时任务，比如一次网络请求），即2秒后返回结果字符串”hi world!”，然后我们在<strong>then</strong>中接收异步结果并打印结果，代码如下：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  Future.delayed(new Duration(seconds: 2),()&#123;    return &quot;hi world!&quot;;  &#125;).then((data)&#123;    print(data);  &#125;);&#125;</code></pre><h4 id="Future-catchError"><a href="#Future-catchError" class="headerlink" title="Future.catchError"></a>Future.catchError</h4><p>如果异步任务发生错误，我们可以在<strong>catchError</strong>中捕获错误，我们将上面示例改为：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  Future.delayed(new Duration(seconds: 2),()&#123;    &#x2F;&#x2F;return &quot;hi world!&quot;;    throw AssertionError(&quot;Error&quot;);  &#125;).then((data)&#123;    &#x2F;&#x2F;执行成功会走到这里    print(&quot;success&quot;);  &#125;).catchError((e)&#123;    &#x2F;&#x2F;执行失败会走到这里    print(e);  &#125;);&#125;</code></pre><p>在本示例中，我们在异步任务中抛出了一个异常，<strong>then</strong>的回调函数将不会被执行，取而代之的是<strong>catchError</strong>回调函数将被调用；但是，并不是只有<strong>catchError</strong>回调才能捕获错误，<strong>then</strong>方法还有一个可选参数<strong>onError</strong>，我们也可以它来捕获异常：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  Future.delayed(new Duration(seconds: 2), () &#123;      &#x2F;&#x2F;return &quot;hi world!&quot;;      throw AssertionError(&quot;Error&quot;);  &#125;).then((data) &#123;      print(&quot;success&quot;);  &#125;, onError: (e) &#123;      print(e);  &#125;);&#125;</code></pre><h4 id="Future-whenComplete"><a href="#Future-whenComplete" class="headerlink" title="Future.whenComplete"></a>Future.whenComplete</h4><p>有些时候，我们会遇到无论异步任务执行成功或失败都需要做一些事的场景，比如在网络请求前弹出加载对话框，在请求结束后关闭对话框。这种场景，有两种方法，第一种是分别在<strong>then</strong>或<strong>catch</strong>中关闭一下对话框，第二种就是使用<strong>Future</strong>的<strong>whenComplete</strong>回调，我们将上面示例改一下：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  Future.delayed(new Duration(seconds: 2),()&#123;    &#x2F;&#x2F;return &quot;hi world!&quot;;    throw AssertionError(&quot;Error&quot;);  &#125;).then((data)&#123;    &#x2F;&#x2F;执行成功会走到这里    print(data);  &#125;).catchError((e)&#123;    &#x2F;&#x2F;执行失败会走到这里    print(e);  &#125;).whenComplete(()&#123;    &#x2F;&#x2F;无论成功或失败都会走到这里  &#125;);&#125;</code></pre><h4 id="Future-wait"><a href="#Future-wait" class="headerlink" title="Future.wait"></a>Future.wait</h4><p>有些时候，我们需要等待多个异步任务都执行结束后才进行一些操作，比如我们有一个界面，需要先分别从两个网络接口获取数据，获取成功后，我们需要将两个接口数据进行特定的处理后再显示到UI界面上，应该怎么做？答案是<strong>Future.wait</strong>，它接受一个<strong>Future</strong>数组参数，只有数组中所有<strong>Future</strong>都执行成功后，才会触发<strong>then</strong>的成功回调，只要有一个<strong>Future</strong>执行失败，就会触发错误回调。下面，我们通过模拟<strong>Future.delayed</strong>来模拟两个数据获取的异步任务，等两个异步任务都执行成功时，将两个异步任务的结果拼接打印出来，代码如下：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  Future.wait([    &#x2F;&#x2F; 2秒后返回结果    Future.delayed(new Duration(seconds: 2), () &#123;        return &quot;hello&quot;;      &#125;),    &#x2F;&#x2F; 4秒后返回结果    Future.delayed(new Duration(seconds: 4), () &#123;        return &quot; world&quot;;      &#125;)  ]).then((results)&#123;    print(results[0]+results[1]);  &#125;).catchError((e)&#123;    print(e);  &#125;);&#125;</code></pre><p>执行上面代码，4秒后你会在控制台中看到“hello world”。</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p><strong>Dart</strong>中的<strong>async/await</strong>和<strong>JavaScript</strong>中的<strong>async/await</strong>功能和用法是一模一样的。</p><h4 id="回调地狱-Callback-Hell"><a href="#回调地狱-Callback-Hell" class="headerlink" title="回调地狱(Callback Hell)"></a>回调地狱(Callback Hell)</h4><p>如果代码中有大量异步逻辑，并且出现大量异步任务依赖其它异步任务的结果时，必然会出现<strong>Future.then</strong>回调中套回调情况。举个例子，比如现在有个需求场景是用户先登录，登录成功后会获得用户ID，然后通过用户ID，再去请求用户个人信息，获取到用户个人信息后，为了使用方便，我们需要将其缓存在本地文件系统，代码如下：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F;先分别定义各个异步任务Future&lt;String&gt; login(String userName, String pwd)&#123;    ...    &#x2F;&#x2F;用户登录&#125;;Future&lt;String&gt; getUserInfo(String id)&#123;    ...    &#x2F;&#x2F;获取用户信息&#125;;Future saveUserInfo(String userInfo)&#123;    ...    &#x2F;&#x2F; 保存用户信息&#125;;</code></pre><p>接下来，执行整个任务流：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">login(&quot;alice&quot;,&quot;******&quot;).then((id)&#123;  &#x2F;&#x2F;登录成功后通过，id获取用户信息  getUserInfo(id).then((userInfo)&#123;    &#x2F;&#x2F;获取用户信息后保存    saveUserInfo(userInfo).then(()&#123;       &#x2F;&#x2F;保存用户信息，接下来执行其它操作        ...    &#125;);  &#125;);&#125;)</code></pre><p>可以感受一下，如果业务逻辑中有大量异步依赖的情况，将会出现上面这种在回调里面套回调的情况，过多的嵌套会导致的代码可读性下降以及出错率提高，并且非常难维护，这个问题被形象的称为回调地狱（Callback Hell）。回调地狱问题在之前JavaScript中非常突出，也是JavaScript被吐槽最多的点，但随着ECMAScript6和ECMAScript7标准发布后，这个问题得到了非常好的解决，而解决回调地狱的两大神器正是ECMAScript6引入了Promise，以及ECMAScript7中引入的async/await。 而在Dart中几乎是完全平移了JavaScript中的这两者：Future相当于Promise，而async/await连名字都没改。接下来我们看看通过Future和async/await如何消除上面示例中的嵌套问题。</p><h4 id="使用Future消除Callback-Hell"><a href="#使用Future消除Callback-Hell" class="headerlink" title="使用Future消除Callback Hell"></a>使用Future消除Callback Hell</h4><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">login(&quot;alice&quot;,&quot;******&quot;).then((id)&#123;      return getUserInfo(id);&#125;).then((userInfo)&#123;    return saveUserInfo(userInfo);&#125;).then((e)&#123;  &#x2F;&#x2F;执行接下来的操&#125;).catchError((e)&#123;  &#x2F;&#x2F;错误处理  print(e);&#125;);</code></pre><p>正如上文所述， “<strong>Future</strong>的所有API的返回值仍然是一个<strong>Future</strong>对象，所以可以很方便的进行链式调用”，如果在<strong>then</strong>中返回的是一个<strong>Future</strong>的话，该<strong>Future</strong>会执行，执行结束后会触发后面的<strong>then</strong>回调，这样依次向下，就避免了层层嵌套。</p><h4 id="使用async-await消除callback-hell"><a href="#使用async-await消除callback-hell" class="headerlink" title="使用async/await消除callback hell"></a>使用async/await消除callback hell</h4><p>通过<strong>Future</strong>回调中再返回<strong>Future</strong>的方式虽然能避免层层嵌套，但是还是有一层回调，有没有一种方式能够让我们可以像写同步代码那样来执行异步任务而不使用回调的方式？答案是肯定的，这就要使用<strong>async/await</strong>了，下面我们先直接看代码，然后再解释，代码如下：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">task() async &#123;  try&#123;    String id &#x3D; await login(&quot;alice&quot;,&quot;******&quot;);    String userInfo &#x3D; await getUserInfo(id);    await saveUserInfo(userInfo);    &#x2F;&#x2F;执行接下来的操作  &#125; catch(e)&#123;    &#x2F;&#x2F;错误处理    print(e);  &#125;&#125;</code></pre><ul><li><strong>async</strong>用来表示函数是异步的，定义的函数会返回一个<strong>Future</strong>对象，可以使用<strong>then</strong>方法添加回调函数。</li><li><strong>await</strong>后面是一个<strong>Future</strong>，表示等待该异步任务完成，异步完成后才会往下走；<strong>await</strong>必须出现在<strong>async</strong>函数内部。</li></ul><p>可以看到，我们通过<strong>async/await</strong>将一个异步流用同步的代码表示出来了。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>其实，无论是在JavaScript还是Dart中，async/await都只是一个语法糖，编译器或解释器最终都会将其转化为一个Promise（Future）的调用链。</p></blockquote><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Stream也是用于接收异步事件数据，和Future不同的是，它可以接收多个异步操作的结果（成功或失败）。 也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 Stream 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">main() &#123;  Stream.fromFutures([    &#x2F;&#x2F; 1秒后返回结果    Future.delayed(new Duration(seconds: 1), () &#123;        return &quot;hello 1&quot;;      &#125;),    &#x2F;&#x2F; 抛出一个异常    Future.delayed(new Duration(seconds: 2),()&#123;        throw AssertionError(&quot;Error&quot;);      &#125;),    &#x2F;&#x2F; 3秒后返回结果    Future.delayed(new Duration(seconds: 3), () &#123;        return &quot;hello 3&quot;;      &#125;)  ]).listen((data)&#123;    print(data);  &#125;, onError: (e)&#123;    print(e.message);  &#125;,onDone: ()&#123;  &#125;);&#125;</code></pre><p>上面的代码依次会输出：</p><pre class="line-numbers language-none"><code class="language-none">I&#x2F;flutter (17666): hello 1I&#x2F;flutter (17666): ErrorI&#x2F;flutter (17666): hello 3</code></pre><h2 id="Dart和Java及JavaScript对比"><a href="#Dart和Java及JavaScript对比" class="headerlink" title="Dart和Java及JavaScript对比"></a>Dart和Java及JavaScript对比</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>之所以将Dart与Java和JavaScript对比，是因为，这两者分别是强类型语言和弱类型语言的典型代表，并且Dart 语法中很多地方也都借鉴了Java和JavaScript。</p></blockquote><h3 id="Dart-vs-Java"><a href="#Dart-vs-Java" class="headerlink" title="Dart vs Java"></a>Dart vs Java</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>客观的来讲，Dart在语法层面确实比Java更有表现力；在VM层面，Dart VM在内存回收和吞吐量都进行了反复的优化，但具体的性能对比，笔者没有找到相关测试数据，但在笔者看来，只要Dart语言能流行，VM的性能就不用担心，毕竟Google在Go（没用VM但有GC）、JavaScript（v8）、Dalvik（Android上的Java VM）上已经有了很多技术积淀。值得注意的是Dart在Flutter中已经可以将GC做到10ms以内，所以Dart和Java相比，决胜因素并不会是在性能方面。而在语法层面，Dart要比Java更有表现力，最重要的是Dart对函数式编程支持要远强于Java(目前只停留在Lambda表达式)，而Dart目前真正的不足是生态，但笔者相信，随着Flutter的逐渐火热，会回过头来反推Dart生态加速发展，对于Dart来说，现在需要的是时间。</p></blockquote><h3 id="Dart-vs-JavaScript"><a href="#Dart-vs-JavaScript" class="headerlink" title="Dart vs JavaScript"></a>Dart vs JavaScript</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>JavaScript的弱类型一直被抓短，所以TypeScript、CoffeeScript甚至是Facebook的flow（虽然并不能算JavaScript的一个超集，但也通过标注和打包工具提供了静态类型检查）才有市场。就笔者使用过的脚本语言中（笔者曾使用过Python、PHP），JavaScript无疑是动态化支持最好的脚本语言，比如在JavaScript中，可以给任何对象在任何时候动态扩展属性，对于精通JavaScript的高手来说，这无疑是一把利剑。但是，任何事物都有两面性，JavaScript的强大的动态化特性也是把双刃剑，你可经常听到另一个声音，认为JavaScript的这种动态性糟糕透了，太过灵活反而导致代码很难预期，无法限制不被期望的修改。毕竟有些人总是对自己或别人写的代码不放心，他们希望能够让代码变得可控，并期望有一套静态类型检查系统来帮助自己减少错误。正因如此，在Flutter中，Dart几乎放弃了脚本语言动态化的特性，如不支持反射、也不支持动态创建函数等。并且Dart在2.0强制开启了类型检查（Strong Mode），原先的检查模式（checked mode）和可选类型（optional type）将淡出，所以在类型安全这个层面来说，Dart和TypeScript、CoffeeScript是差不多的，所以单从这一点来看，Dart并不具备什么明显优势，但综合起来看，Dart既能进行服务端脚本、APP开发、web开发，这就有优势了！</p></blockquote><h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><p>本文大量学习借鉴了以下文章</p><p>《Dart的语法详解系列篇（二）– 类与函数》 作者：<strong>AWeiLoveAndroid</strong> 链接：<a href="https://www.jianshu.com/p/44ae73a58ebc">https://www.jianshu.com/p/44ae73a58ebc</a></p><p>《30分钟掌握Dart语言》 作者：<strong>彡廿</strong> 链接：<a href="https://www.jianshu.com/p/06aebcad0543">https://www.jianshu.com/p/06aebcad0543</a></p><p>《Dart语言简介》 出处 <strong>Flutter中文网</strong> 链接：<a href="https://book.flutterchina.club/chapter1/dart.html">https://book.flutterchina.club/chapter1/dart.html</a></p><p>《Dart 断言(assert)和异常》 作者：<strong>name不是null</strong> 链接：<a href="https://www.jianshu.com/p/7c5c0a1f118a">https://www.jianshu.com/p/7c5c0a1f118a</a></p><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><ul><li>作者：麟子</li><li>地址：<a href="https://swz128.top/post/Dart">https://swz128.top/post/Dart</a></li><li>协议：<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 欢迎转载，务必注明出处</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dart-学习总结&quot;&gt;&lt;a href=&quot;#Dart-学习总结&quot; class=&quot;headerlink&quot; title=&quot;Dart 学习总结&quot;&gt;&lt;/a&gt;Dart 学习总结&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;本文大量学习借鉴了 「AWeiLoveAndroid」、 「name</summary>
      
    
    
    
    <category term="教程" scheme="https://swz128.top/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Dart" scheme="https://swz128.top/tags/Dart/"/>
    
    <category term="学习" scheme="https://swz128.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="教程" scheme="https://swz128.top/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>NCL(The NCAR Command Language)Linux,Windows多平台安装</title>
    <link href="https://swz128.top/post/NCL.html"/>
    <id>https://swz128.top/post/NCL.html</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2019-11-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NCL-The-NCAR-Command-Language-Linux-Windows多平台安装"><a href="#NCL-The-NCAR-Command-Language-Linux-Windows多平台安装" class="headerlink" title="NCL(The NCAR Command Language)Linux,Windows多平台安装"></a>NCL(The NCAR Command Language)Linux,Windows多平台安装</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>NCL(The NCAR Command Language)是一种专门为科学数据处理以及数据可视化设计的高级语言，很适合用在气象数据的处理和可视化上。–百度百科</p></blockquote><p><img src="https://img.swz128.top/NCL_File/NCLMainImage_logos.png" alt="logo"></p><h2 id="Linux下安装"><a href="#Linux下安装" class="headerlink" title="Linux下安装"></a>Linux下安装</h2><p>NCL官网：<a href="http://www.ncl.ucar.edu/">http://www.ncl.ucar.edu/</a><br>进入到下载页面</p><p><img src="https://img.swz128.top/NCL_File/01.png" alt="01"></p><p>ncl的官网提供了3种安装方式</p><ol><li><p><code>conda</code></p></li><li><p><code>二进制安装包</code></p></li><li><p><code>源码编译安装</code></p></li></ol><p><img src="https://img.swz128.top/NCL_File/02.png" alt="02"></p><h3 id="1-Conda方式安装NCL"><a href="#1-Conda方式安装NCL" class="headerlink" title="1.Conda方式安装NCL"></a>1.Conda方式安装NCL</h3><h4 id="Conda简介"><a href="#Conda简介" class="headerlink" title="Conda简介"></a>Conda简介</h4><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和Windows，也可以打包和分发其他软件。</p></blockquote><p>Conda的安装详见下面这个文章</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>作者：卖萌哥<br>链接：<a href="https://www.jianshu.com/p/edaa744ea47d">https://www.jianshu.com/p/edaa744ea47d</a></p></blockquote><h4 id="安装ncl"><a href="#安装ncl" class="headerlink" title="安装ncl"></a>安装ncl</h4><p>如果您已有conda，但已有一段时间未更新，则可能需要通过从UNIX终端窗口键入以下内容来更新它：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda update -n root --all</code></pre><p>然后安装<code>ncl-stable</code>软件包</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda create -n ncl_stable -c conda-forge nclsource activate ncl_stable</code></pre><p>安装完成！</p><p>输入如下代码，检测安装结果：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ncl -Vng4ex xy05n -clean -W png</code></pre><p>显示如下：</p><p><img src="https://img.swz128.top/NCL_File/03.png" alt="03"></p><h3 id="2-二进制包安装"><a href="#2-二进制包安装" class="headerlink" title="2.二进制包安装"></a>2.二进制包安装</h3><p>在下载页面中</p><p><img src="https://img.swz128.top/NCL_File/04.png" alt="04"></p><p>点击里面的<code>a list of binaries</code>链接。进入到二进制安装包的下载页面</p><p><img src="https://img.swz128.top/NCL_File/05.png"></p><p>在下载页面，提供了多个Linux平台的下载链接，比如常见的CentOS、Debian等，你根据自己使用的平台来选择。网站在国外，下载会很慢，请耐心等待。</p><hr><p>如果不介意版本新旧的话，可以在我分享的百度网盘链接下载：</p><p>链接: <a href="https://pan.baidu.com/s/1wjMWLIdpPgUNmBt5O8RjHQ">https://pan.baidu.com/s/1wjMWLIdpPgUNmBt5O8RjHQ</a>  密码: 3bi6</p><p>如果链接挂掉，请务必邮件告知我。</p><hr><p>因为NCL是图形化编程，因此必须在Linux的图形桌面下安装。</p><p>打开终端</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo mkdir &#x2F;usr&#x2F;local&#x2F;ncl-6.4.0 #以我分享的ncl版本为例sudo tar -xvf ～&#x2F;ncl_ncarg-6.4.0-CentOS7.3_64bit_gnu485.tar.gz -C &#x2F;usr&#x2F;local&#x2F;ncl-6.4.0#假设你的ncl包在用户目录下</code></pre><p>如果第一次执行的时候报错，提示缺少libgfortran.so.3这个库文件，我们来安装这个包。命令是：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum install libgfortran -y #以CentOS为例，其他平台类似，具体请自行百度</code></pre><p>如果有其他问题，请查阅<a href="http://www.ncl.ucar.edu/Download/linux.shtml">http://www.ncl.ucar.edu/Download/linux.shtml</a></p><p>为了更方便使用，我们将ncl的路径添加到系统路径中去</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim ~&#x2F;.bashrc</code></pre><p>在结尾添加如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export NCARG_ROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;ncl-6.4.0export PATH&#x3D;$NCARG_ROOT&#x2F;bin:$PATH</code></pre><p>然后保存退出（:wq）。（vim是一款极其著名的命令行编辑器，其操作使用方法可以百度一下）</p><p>然后执行命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source ~&#x2F;.bashrc</code></pre><p>测试一下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ncl -V</code></pre><p>如果能正确显示NCL的版本号，说明安装完毕且正确。</p><h3 id="3-源码编译安装"><a href="#3-源码编译安装" class="headerlink" title="3.源码编译安装"></a>3.源码编译安装</h3><p>略略略，有时间再更新^_^</p><h2 id="Windows下安装"><a href="#Windows下安装" class="headerlink" title="Windows下安装"></a>Windows下安装</h2><h3 id="在Windows下安装Ubuntu子系统"><a href="#在Windows下安装Ubuntu子系统" class="headerlink" title="在Windows下安装Ubuntu子系统"></a>在Windows下安装Ubuntu子系统</h3><h4 id="安装-Windows-10-的-Linux-子系统组件"><a href="#安装-Windows-10-的-Linux-子系统组件" class="headerlink" title="安装 Windows 10 的 Linux 子系统组件"></a>安装 Windows 10 的 Linux 子系统组件</h4><p>顺序： -&gt; 系统设置 -&gt; 应用 -&gt; 右侧的程序和功能 -&gt; 启动或关闭windows功能 -&gt; 勾选适用于 Linux 的 Windows 子系统</p><p><img src="https://img.swz128.top/NCL_File/06.jpg" alt="06"></p><p>确定后，重启电脑，系统更新配置。</p><hr><p>重启后，打开 Windows 应用市场，输入 linux 搜索，选择你自己想要的系统版本，选择 Ubuntu</p><p>然后点击启动，第一次会进行初始化安装。</p><p>初始化安装完成，设置帐号密码，用户名我们直接使用 root ，然后设置下密码就搞定了（在Linux下输入密码是不会显示*的）</p><p>windows 的 CMD 不好用，推荐个很不错的替代软件 <code>Cmder</code> 。下载地址：<a href="http://cmder.net/">http://cmder.net/</a></p><h4 id="Ubuntu基础配置"><a href="#Ubuntu基础配置" class="headerlink" title="Ubuntu基础配置"></a>Ubuntu基础配置</h4><p>更换国内数据源</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.backupsudo vim &#x2F;etc&#x2F;apt&#x2F;sources.list</code></pre><p>在vim中，按<code>i</code>进入输入模式</p><p>我们使用清华的源</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse</code></pre><p>将以上全复制进<code>sources.list</code>，按<code>Esc</code>退出到命令模式，保存退出（<code>:wq</code>）</p><p>然后更新</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get update</code></pre><h4 id="安装附加软件包"><a href="#安装附加软件包" class="headerlink" title="安装附加软件包"></a><span id="jump-01">安装附加软件包</span></h4><p>接下来，我们需要安装一些ncl可能需要的包</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get install csh libfontconfig gfortran libgfortran3sudo apt-get install libxrender-dev libx11-dev libxrender1sudo apt-get install libssh2-1 libgomp1sudo apt-get install firefox imagemagick</code></pre><p>NCL需要图形界面，我们需要安装<code>Xming</code>来显示图形。<code>Xming</code>的下载链接 <a href="https://sourceforge.net/projects/xming/">https://sourceforge.net/projects/xming/</a></p><p>有时候Xming会出现问题，尽量在启动Ubuntu之前先启动Xming。</p><p>如果你觉得Xming无法满足你，你可以参考这篇文章：<a href="https://blog.csdn.net/u011138447/article/details/78262369">https://blog.csdn.net/u011138447/article/details/78262369</a></p><h4 id="下载NCL"><a href="#下载NCL" class="headerlink" title="下载NCL"></a>下载NCL</h4><p>你可以直接用命令下载到Ubuntu</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget https:&#x2F;&#x2F;www.earthsystemgrid.org&#x2F;download&#x2F;fileDownload.html?logicalFileId&#x3D;246ab3ec-fa02-11e6-a976-00c0f03d5b7c</code></pre><p>或者，在<code>/mnt/</code>有c、d……之类的目录，其对应Windows的C盘、D盘…… 所以你可以将你之前下载好的包拷贝到Ubuntu的当前工作目录。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo mkdir &#x2F;usr&#x2F;local&#x2F;ncl-6.6.2 #以6.6.2为例sudo tar -zxf ~&#x2F;ncl_ncarg-6.6.2-Debian7.11_64bit_gnu472.tar.gz -C &#x2F;usr&#x2F;local&#x2F;ncl-6.6.2#假设你的ncl包在你的用户目录下</code></pre><p>然后</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim ~&#x2F;.bashrc</code></pre><p>在vim中，按<code>i</code>进入输入模式，在最后添加</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export NCARG_ROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;ncl-6.6.2export PATH&#x3D;$NCARG_ROOT&#x2F;bin:$PATHexport DISPLAY&#x3D;:0</code></pre><p>按<code>Esc</code>退出到命令模式，保存退出（<code>:wq</code>）。</p><h4 id="测试你的NCL"><a href="#测试你的NCL" class="headerlink" title="测试你的NCL"></a>测试你的NCL</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ncl -V</code></pre><p>如果输入ncl版本，例如“6.4.2”，说明安装成功。</p><p>或者可以</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cp $NCARG_ROOT&#x2F;lib&#x2F;ncarg&#x2F;nclex&#x2F;xyplot&#x2F;xy04n.ncl .ncl xy04n.ncl</code></pre><p>会输出一张图表</p><h4 id="一些可能的问题"><a href="#一些可能的问题" class="headerlink" title="一些可能的问题"></a>一些可能的问题</h4><p>如果出显了一些错误，比如告诉你缺少了”lib<em>xxxx</em>.so”这类的库，你可以用”sudo apt-get install xxxx”来安装缺少的库或者包。</p><p>如果你看到了这样的错误：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">warning:GKS:GOPWK: --X driver error: error opening display</code></pre><p>这可能是你没有设置DISPLAY的环境变量，或者设置错误，输入</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">printenv DISPLAY</code></pre><p>详情请看这篇文章：<a href="http://www.ncl.ucar.edu/Download/windows_linux_subsystem.shtml#SetDisplay">http://www.ncl.ucar.edu/Download/windows_linux_subsystem.shtml#SetDisplay</a></p><p>如果你的问题还没有解决，也可以参考这篇文章：<a href="https://wenku.baidu.com/view/a5f722906e1aff00bed5b9f3f90f76c660374c61.html">https://wenku.baidu.com/view/a5f722906e1aff00bed5b9f3f90f76c660374c61.html</a> window10下Linux子系统 + NCL 安装记录</p><h3 id="虚拟机下安装Ubuntu来运行ncl"><a href="#虚拟机下安装Ubuntu来运行ncl" class="headerlink" title="虚拟机下安装Ubuntu来运行ncl"></a>虚拟机下安装Ubuntu来运行ncl</h3><p>在Windows下有两款常用的虚拟机软件，VMware和Oracle VM VirtualBox，其中VMware是付费软件，Oracle VM VirtualBox是一款多平台的开源免费软件。<br>VMware附许可码：链接: <a href="https://pan.baidu.com/s/1eAApTcS-J-JY4MSApsHXcQ">https://pan.baidu.com/s/1eAApTcS-J-JY4MSApsHXcQ</a>  密码: 25ut<br>Oracle VM VirtualBox的官网下载链接： <a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a></p><p>我们还需要Ubuntu系统镜像文件，考虑到国内的网络环境，我们选择在清华大学的开源软件镜像站下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/eoan/ubuntu-19.10-desktop-amd64.iso">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/eoan/ubuntu-19.10-desktop-amd64.iso</a></p><p>你也可以在这 <a href="https://mirrors.tuna.tsinghua.edu.cn/#">https://mirrors.tuna.tsinghua.edu.cn/#</a> 找到最新版</p><p><img src="https://img.swz128.top/NCL_File/qinghua.png"></p><h4 id="Oracle-VM-VirtualBox"><a href="#Oracle-VM-VirtualBox" class="headerlink" title="Oracle VM VirtualBox"></a>Oracle VM VirtualBox</h4><p>我这里使用Oracle VM VirtualBox来介绍一下安装</p><p>装好Oracle VM VirtualBox后</p><p><img src="https://img.swz128.top/NCL_File/14.png"></p><p>新建</p><p><img src="https://img.swz128.top/NCL_File/15.png"></p><p>尽量不要把安装文件夹放在C盘</p><p><img src="https://img.swz128.top/NCL_File/16.png"></p><p>剩下的一路默认到底</p><p><img src="https://img.swz128.top/NCL_File/17.png"></p><p>然后点启动：</p><p><img src="https://img.swz128.top/NCL_File/21.png"></p><p>这时候会弹出一个对话窗，然后可以选择我下好的Ubuntu系统镜像</p><p><img src="https://img.swz128.top/NCL_File/22.png"></p><p><img src="https://img.swz128.top/NCL_File/23.png"></p><p>然后选择中文</p><p><img src="https://img.swz128.top/NCL_File/24.png"></p><p>安装Ubuntu</p><p><img src="https://img.swz128.top/NCL_File/25.png"></p><p>如果网路状况不好，可以不选择“安装Ubuntu时下载更新”</p><p><img src="https://img.swz128.top/NCL_File/27.png"></p><p>然后</p><p><img src="https://img.swz128.top/NCL_File/28.png"></p><p><img src="https://img.swz128.top/NCL_File/29.png"></p><p>之后输入个人信息：用户名，口令等。单击“继续”，安装过程可能需要几十分钟，请耐心等待。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>启动Ubuntu，打开终端窗口</p><p>一个要点是：命令，文件名要通过<code>Tab</code>补全，这样就会减少录入错误。</p><p>介于国内网络环境，我们先把数据源更换为清华的开源软件镜像站</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.backupsudo vim &#x2F;etc&#x2F;apt&#x2F;sources.list</code></pre><p>在vim中，按<code>i</code>进入输入模式（如果提示没有安装vim，可以使用<code>nano</code>来编辑，可以参考这篇文章：<a href="https://man.linuxde.net/nano%EF%BC%89">https://man.linuxde.net/nano）</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse</code></pre><p>按Esc退出到命令模式，保存退出（:wq）。</p><p>通过</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get update;sudo apt-get upgrade</code></pre><p>来更新一下系统</p><p>然后可以参考前面的  <a href="#jump-01">跳转</a> 来完成配置和ncl安装。</p><h3 id="Cygwin下运行ncl"><a href="#Cygwin下运行ncl" class="headerlink" title="Cygwin下运行ncl"></a>Cygwin下运行ncl</h3><p>可以参考这个：<a href="https://blog.csdn.net/Vicky510475733/article/details/79101561">https://blog.csdn.net/Vicky510475733/article/details/79101561</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Installing NCL with “conda” <a href="http://www.ncl.ucar.edu/Download/conda.shtml">http://www.ncl.ucar.edu/Download/conda.shtml</a></p><p>NCL在Linux安装教程 <a href="https://jingyan.baidu.com/article/ab69b2707beaea2ca7189ffc.html">https://jingyan.baidu.com/article/ab69b2707beaea2ca7189ffc.html</a></p><p>conda的安装与使用 <a href="https://www.jianshu.com/p/edaa744ea47d">https://www.jianshu.com/p/edaa744ea47d</a></p><p>告别NCL 拥抱Python <a href="https://cloud.tencent.com/developer/article/1471168">https://cloud.tencent.com/developer/article/1471168</a></p><p>NCL 6.5.0 在Ubuntu 16.04下的安装 <a href="https://www.jianshu.com/p/ce680e7ec8ed">https://www.jianshu.com/p/ce680e7ec8ed</a></p><p>Running NCL under Linux systems <a href="http://www.ncl.ucar.edu/Download/linux.shtml">http://www.ncl.ucar.edu/Download/linux.shtml</a></p><p>Installing and running NCL on Windows 10 Linux Bash shell <a href="http://www.ncl.ucar.edu/Download/windows_linux_subsystem.shtml">http://www.ncl.ucar.edu/Download/windows_linux_subsystem.shtml</a></p><p>Windows10安装Linux子系统Ubuntu <a href="https://blog.csdn.net/zhouzme/article/details/78780479">https://blog.csdn.net/zhouzme/article/details/78780479</a></p><p>Windows 10’s Bash shell can run graphical Linux applications with this trick <a href="https://www.pcworld.com/article/3055403/windows-10s-bash-shell-can-run-graphical-linux-applications-with-this-trick.html">https://www.pcworld.com/article/3055403/windows-10s-bash-shell-can-run-graphical-linux-applications-with-this-trick.html</a></p><p>How to Install and Use the Linux Bash Shell on Windows 10 <a href="https://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/">https://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/</a></p><p>windows 10中的ubuntu子系统安装桌面环境的方法（How to install Ubuntu-desktop in windows 10 Subsystem for Linux） <a href="https://blog.csdn.net/u011138447/article/details/78262369">https://blog.csdn.net/u011138447/article/details/78262369</a></p><p>window10下Linux子系统 + NCL 安装记录 <a href="https://wenku.baidu.com/view/a5f722906e1aff00bed5b9f3f90f76c660374c61.html">https://wenku.baidu.com/view/a5f722906e1aff00bed5b9f3f90f76c660374c61.html</a></p><p>Set DISPLAY environment variable <a href="http://www.ncl.ucar.edu/Download/windows_linux_subsystem.shtml#SetDisplay">http://www.ncl.ucar.edu/Download/windows_linux_subsystem.shtml#SetDisplay</a></p><p>nano命令 <a href="https://man.linuxde.net/nano">https://man.linuxde.net/nano</a></p><p>新手进行Cygwin/X(Windows)系统下安装使用NCL <a href="https://blog.csdn.net/Vicky510475733/article/details/79101561">https://blog.csdn.net/Vicky510475733/article/details/79101561</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="告别NCL-拥抱Python"><a href="#告别NCL-拥抱Python" class="headerlink" title="告别NCL 拥抱Python"></a>告别NCL 拥抱Python</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>晴天一声雷，NCL官网发布重要通告，他们决定不再更新NCL转而向Python发展。WHAT???我刚把NCL用熟了你就跟我说这个。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>但做出这种选择确实也是有一定道理的，python在地球科学社区中的应用越来越广泛，很多优秀的团队还有大牛基于python开发出了不少地球科学相关的库。得益于这些优秀的库，近些年python在地球科学领域快速发展，并逐渐成为未来的趋势。现在python不但可以替代NCL而且还能提供很多NCL不具备的功能。</p></blockquote><h3 id="NCL-to-Python"><a href="#NCL-to-Python" class="headerlink" title="NCL to Python"></a>NCL to Python</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>NCL的功能在python中转为了PyNIO和PyNGL这两个库：<br>1.PyNIO使用了NetCDF的接口用来读写各种类型的数据，包括NetCDF、GRIB、HDF等。<br>2.PyNGL是一个可视化的库，里面的参数设置和NCL中的很相似。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>其实让大家从一门自己熟悉的语言转换到另一门语言的过程是很痛苦的，前期肯定是特别的不习惯，但只要熬过了短暂的过渡期后面很快就能适应过来。不过幸运的是NCL团队很贴心的给出了NCL向Python过渡的指导手册（NCL-to-Python Transition Guide），链接在文末。熟悉NCL的小伙伴借助官方的文档一定能很快的完成向python的过渡。</p></blockquote><p>NCL-to-Python Transition Guide (PDF) <a href="http://www.ncl.ucar.edu/Document/Manuals/NCL_to_Python/Transition_Guide_NCL_PyNGL.pdf">http://www.ncl.ucar.edu/Document/Manuals/NCL_to_Python/Transition_Guide_NCL_PyNGL.pdf</a></p><h3 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h3><ul><li>作者：麟子</li><li>地址：<a href="https://swz128.top/post/NCL">https://swz128.top/post/NCL</a></li><li>协议：<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 欢迎转载，务必注明出处</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NCL-The-NCAR-Command-Language-Linux-Windows多平台安装&quot;&gt;&lt;a href=&quot;#NCL-The-NCAR-Command-Language-Linux-Windows多平台安装&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="教程" scheme="https://swz128.top/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="NCL" scheme="https://swz128.top/tags/NCL/"/>
    
    <category term="Linux" scheme="https://swz128.top/tags/Linux/"/>
    
    <category term="Windows" scheme="https://swz128.top/tags/Windows/"/>
    
  </entry>
  
</feed>
