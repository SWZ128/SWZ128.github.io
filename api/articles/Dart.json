{"title":"Dart 语言简易入门","uid":"17f5327947b1d53e6c1283a3094dcb3b","slug":"Dart","date":"2019-12-31T16:00:00.000Z","updated":"2019-12-31T16:00:00.000Z","comments":true,"path":"api/articles/Dart.json","keywords":"Linux, LaTeX, Blog","cover":"https://img.swz128.top/Dart_File/01.png","content":"<h1 id=\"Dart-学习总结\"><a href=\"#Dart-学习总结\" class=\"headerlink\" title=\"Dart 学习总结\"></a>Dart 学习总结</h1><p><strong>本文大量学习借鉴了 「AWeiLoveAndroid」、 「name不是null」 与 「彡廿」 的博文和 「Flutter中文网」 的入门指南，在此表示感谢，被引用文章链接见文末</strong></p>\n<h2 id=\"1-变量\"><a href=\"#1-变量\" class=\"headerlink\" title=\"1.变量\"></a>1.变量</h2><p>可以用C\\C++风格的方式声明变量，如<strong>int, bool, String</strong>等，也可以用<strong>var</strong>或者<strong>dynamic</strong>来声明，Dart会自动推断类型。</p>\n<p>没有赋初值的变量都会有默认值<strong>null</strong>。</p>\n<p><strong>final</strong>要求变量只能初始化一次，并不要求赋的值一定是编译时常量，可以是常量也可以不是。而<strong>const</strong>要求在声明时初始化，并且赋值必需为编译时常量。</p>\n<p>Dart有如下几种内建的数据类型：</p>\n<ul>\n<li>numbers (var, num, int, double)</li>\n<li>strings (var, String)</li>\n<li>booleans (var, bool)</li>\n<li>lists (或者是arrays)</li>\n<li>maps (类似Python里的字典)</li>\n<li>runes（UTF-32字符集的字符）</li>\n<li>symbols</li>\n</ul>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">main() &#123;\n  &#x2F;&#x2F; numbers\n  var a &#x3D; 0;\n  int b &#x3D; 1;\n  double c &#x3D; 0.1;\n\n  &#x2F;&#x2F; strings\n  var s1 &#x3D; &#39;hello&#39;;\n  String s2 &#x3D; &quot;world&quot;;\n\n  &#x2F;&#x2F; booleans\n  var real &#x3D; true;\n  bool isReal &#x3D; false;\n\n  &#x2F;&#x2F; lists\n  var arr &#x3D; [1, 2, 3, 4, 5];\n  List&lt;String&gt; arr2 &#x3D; [&#39;hello&#39;, &#39;world&#39;, &quot;123&quot;, &quot;456&quot;];\n  List&lt;dynamic&gt; arr3 &#x3D; [1, true, &#39;haha&#39;, 1.0];\n\n  &#x2F;&#x2F; maps\n  var map &#x3D; new Map();\n  map[&#39;name&#39;] &#x3D; &#39;zhangsan&#39;;\n  map[&#39;age&#39;] &#x3D; 10;\n  Map m &#x3D; new Map();\n  m[&#39;a&#39;] &#x3D; &#39;a&#39;;\n\n  &#x2F;&#x2F;runes，Dart 中 使用runes 来获取UTF-32字符集的字符。String的 codeUnitAt and codeUnit属性可以获取UTF-16字符集的字符\n  var clapping &#x3D; &#39;\\u&#123;1f44f&#125;&#39;;\n  print(clapping); &#x2F;&#x2F; 打印的是拍手emoji的表情\n\n  &#x2F;&#x2F; symbols\n  print(#s &#x3D;&#x3D; new Symbol(&quot;s&quot;)); &#x2F;&#x2F; true\n&#125;</code></pre>\n\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"函数返回值\"><a href=\"#函数返回值\" class=\"headerlink\" title=\"函数返回值\"></a>函数返回值</h3><p>所有的函数都有返回值，如果没有指定<strong>return</strong>语句，那么该函数的返回值为<strong>null</strong>。</p>\n<p>Dart是一个面向对象的编程语言，所以即使是函数也是一个对象，也有一种类型<strong>Function</strong>，这就意味着函数可以赋值给某个变量或者作为参数传给另外的函数。虽然Dart推荐你给函数加上返回值，但是不加返回值的函数同样可以正常工作，另外你还可以用 <strong>=&gt;</strong> 代替 <strong>return</strong> 语句，比如下面的代码：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">&#x2F;&#x2F; 声明返回值\nint add(int a, int b) &#123;\n  return a + b;\n&#125;\n\n&#x2F;&#x2F; 不声明返回值\nadd2(int a, int b) &#123;\n  return a + b;\n&#125;\n\n&#x2F;&#x2F; &#x3D;&gt;是return语句的简写\nadd3(a, b) &#x3D;&gt; a + b;\n\nmain() &#123;\n  print(add(1, 2)); &#x2F;&#x2F; 3\n  print(add2(2, 3)); &#x2F;&#x2F; 5\n  print(add3(1, 2)); &#x2F;&#x2F; 3\n&#125;</code></pre>\n\n<h3 id=\"可选的命名参数\"><a href=\"#可选的命名参数\" class=\"headerlink\" title=\"可选的命名参数\"></a>可选的命名参数</h3><pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">sayHello(String name) &#123;\n  print(&quot;hello, my name is $name&quot;);\n&#125;\nsayHello2(&#123;String name&#125;) &#123;\n  print(&quot;hello, myname is $name&quot;);\n&#125;\n\nsayHello3(&#123;name: String&#125;) &#123;\n  print(&quot;hello, my name is $name&quot;);\n&#125;\n\nmain() &#123;\n  &#x2F;&#x2F; 打印 hello, my name is zhangsan\n  sayHello(&#39;zhangsan&#39;);\n\n  &#x2F;&#x2F; 打印 hello, my name is wangwu\n  sayHello2(name: &#39;wangwu&#39;);\n\n  sayHello3(name: &#39;wangwu&#39;);\n&#125;\n</code></pre>\n\n<p>可以看到，定义命名参数时，你可以以 <strong>{type paramName}</strong> 或者 <strong>{paramName: type}</strong> 两种方式声明参数，而调用命名参数时，需要以 <strong>funcName(paramName: paramValue)</strong> 的形式调用。</p>\n<p>命名参数的参数并<strong>不是必须</strong>的，所以上面的代码中，如果调用 <strong>sayHello()</strong> 不带任何参数，也是可以的，只不过最后打印出来的结果是：hello, my name is null，在Flutter开发中，你可以使用 <strong>@required</strong> 注解来标识一个命名参数，这代表该参数是必须的，你不传则会报错，比如下面的代码：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">const Scrollbar(&#123;Key key, @required Widget child&#125;)</code></pre>\n\n<h3 id=\"可选的位置参数\"><a href=\"#可选的位置参数\" class=\"headerlink\" title=\"可选的位置参数\"></a>可选的位置参数</h3><p>使用中括号 <strong>[]</strong> 括起来的参数是函数的位置参数，代表该参数可传可不传，位置参数只能放在函数的参数列表的最后面，如下代码所示：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">sayHello(String name, int age, [String hobby]) &#123; &#x2F;&#x2F; 位置参数可以有多个，比如[String a, int b]\n  StringBuffer sb &#x3D; new StringBuffer();\n  sb.write(&quot;hello, this is $name and I am $age years old&quot;);\n  if (hobby !&#x3D; null) &#123;\n    sb.write(&quot;, my hobby is $hobby&quot;);\n  &#125;\n  print(sb.toString());\n&#125;\n\nmain() &#123;\n  &#x2F;&#x2F; hello, this is zhangsan and I am 20 years old\n  sayHello(&quot;zhangsan&quot;, 20);\n  &#x2F;&#x2F; hello, this is zhangsan and I am 20 years old, my hobby is play football\n  sayHello(&quot;zhangsan&quot;, 20, &quot;play football&quot;);\n&#125;</code></pre>\n\n<p><strong>注意，不能同时使用可选的位置参数和可选的命名参数。</strong></p>\n<h3 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h3><pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">&#x2F;&#x2F; 命名参数的默认值\nint add(&#123;int a, int b &#x3D; 3&#125;) &#123; &#x2F;&#x2F; 不能写成：int add(&#123;a: int, b: int &#x3D; 3&#125;)\n    return a + b;\n&#125;\n\n&#x2F;&#x2F; 位置参数的默认值\nint sum(int a, int b, [int c &#x3D; 3]) &#123;\n  return a + b + c;\n&#125;\n\nmain() &#123;\n  print(add(a: 1)); &#x2F;&#x2F;4\n  print(sum(1,2)); &#x2F;&#x2F;6\n&#125;</code></pre>\n\n<h3 id=\"函数作为变量\"><a href=\"#函数作为变量\" class=\"headerlink\" title=\"函数作为变量\"></a>函数作为变量</h3><pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">var say &#x3D; (str)&#123;\n  print(str);\n&#125;;\n\nmain()&#123;\n  say(&quot;hi world&quot;);\n&#125;</code></pre>\n\n<h3 id=\"函数作为参数传递\"><a href=\"#函数作为参数传递\" class=\"headerlink\" title=\"函数作为参数传递\"></a>函数作为参数传递</h3><pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">List list &#x3D; [10, 7, 23];\nlist.forEach((item) &#123;\n  print(&#39;$item&#39;);\n&#125;);</code></pre>\n<p>这里面的参数是一个函数 <strong>(){}</strong> (省略函数名)。<strong>forEach</strong> 源码是：<strong>forEach (void f(E element))</strong>,它的参数是一个函数。以上语句可以简写成：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">list.forEach((item) &#x3D;&gt; print(&#39;$item&#39;));</code></pre>\n\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">void execute(var callback) &#123;\n    callback();\n&#125;\nmain() &#123;\n  execute(() &#x3D;&gt; print(&quot;xxx&quot;)); &#x2F;&#x2F;xxx\n&#125;\n</code></pre>\n\n<h3 id=\"函数别名\"><a href=\"#函数别名\" class=\"headerlink\" title=\"函数别名\"></a>函数别名</h3><p><strong>typedef</strong>,会保留类型信息。</p>\n<p>以下代码，它不使用<strong>typedef</strong>：我们可以看到funs是一个函数，它是<strong>Function</strong>类型。</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">class Demo &#123;\n  Function funs;\n  Demo (int f(Object a, Object b)) &#123;\n    funs &#x3D; f;\n  &#125;\n&#125;\n\nint test(Object a, Object b) &#x3D;&gt; 0;\n\nvoid main() &#123;\n  Demo demo &#x3D; Demo(test);\n  &#x2F;&#x2F; funs是一个函数，但它是哪一种类型的函数?\n  print(demo.funs is Function); &#x2F;&#x2F; true\n&#125;</code></pre>\n\n<p>可以使用<strong>typedef</strong>给函数取个别名。接下来使用<strong>typedef</strong>改造一下。</p>\n<p>1.给<strong>Function</strong>取一个别名叫做<strong>TypedefFuns</strong></p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">typedef TypedefFuns &#x3D; int Function(Object a, Object b);</code></pre>\n\n<p>2.<strong>Demo</strong>类里的构造方法使用这个别名</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">class Demo &#123;\n  TypedefFuns funs;\n  Demo(this.funs);\n&#125;</code></pre>\n\n<p>3.使用<strong>Demo</strong>类，传入一个函数。这里给<strong>Demo</strong>类传入了一个函数<strong>test</strong>。判断<strong>demo.funs</strong>属于哪一种类型。</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">int test(Object a, Object b) &#x3D;&gt; 0;\n\nvoid main() &#123;\n  Demo demo &#x3D; Demo(test);\n  print(demo.funs is Function); &#x2F;&#x2F; true\n  print(demo.funs is Demo); &#x2F;&#x2F; false\n&#125;</code></pre>\n<p><strong>typedef</strong>还可以这样使用</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">typedef TypedefFuns2&lt;T&gt; &#x3D; int Function(T a, T b);\nint test2(int a, int b) &#x3D;&gt; a - b;\nvoid main() &#123;\n  print(test2 is TypedefFuns2&lt;int&gt;); &#x2F;&#x2F; True\n&#125;</code></pre>\n\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><h3 id=\"运算符-1\"><a href=\"#运算符-1\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">main() &#123;\n  &#x2F;&#x2F; 与Java相同的运算符操作\n\n  int a &#x3D; 1;\n  ++a;\n  a++;\n  var b &#x3D; 1;\n  print(a &#x3D;&#x3D; b);  &#x2F;&#x2F; false\n  print(a * b); &#x2F;&#x2F; 3\n  bool real &#x3D; false;\n  real ? print(&#39;real&#39;) : print(&#39;not real&#39;); &#x2F;&#x2F; not real\n  print(real &amp;&amp; a &#x3D;&#x3D; b); &#x2F;&#x2F; false\n  print(real || a &#x3D;&#x3D; 3); &#x2F;&#x2F; true\n  print(a !&#x3D; 2); &#x2F;&#x2F; true\n  print(a &lt;&#x3D; b); &#x2F;&#x2F; false\n  var c &#x3D; 9;\n  c +&#x3D; 10;\n  print(&quot;c &#x3D; $c&quot;); &#x2F;&#x2F; c &#x3D; 19\n  print(1&lt;&lt;2); &#x2F;&#x2F; 4\n\n  &#x2F;&#x2F; 与Java不太一样的运算符操作\n\n  &#x2F;&#x2F; is运算符用于判断一个变量是不是某个类型的数据\n  &#x2F;&#x2F; is!则是判断变量不是某个类型的数据\n  var s &#x3D; &quot;hello&quot;;\n  print(s is String); &#x2F;&#x2F; true\n  var num &#x3D; 6;\n  print(num is! String); &#x2F;&#x2F; true\n\n  &#x2F;&#x2F; ~&#x2F;才是取整运算符，如果使用&#x2F;则是除法运算，不取整\n  int k &#x3D; 1;\n  int j &#x3D; 2;\n  print(k &#x2F; j); &#x2F;&#x2F; 0.5\n  print(k ~&#x2F; j); &#x2F;&#x2F; 0\n\n  &#x2F;&#x2F; as运算符类似于Java中的cast操作，将一个对象强制类型转换\n  (emp as Person).teach();\n\n  &#x2F;&#x2F; ??&#x3D;运算符 如果 ??&#x3D; 运算符前面的变量为null，则赋值，否则不赋值\n  var param1 &#x3D; &quot;hello&quot;, param2 &#x3D; null;\n  param1 ??&#x3D; &quot;world&quot;;\n  param2 ??&#x3D; &quot;world&quot;;\n  print(&quot;param1 &#x3D; $param1&quot;); &#x2F;&#x2F; param1 &#x3D; hello\n  print(&quot;param2 &#x3D; $param2&quot;); &#x2F;&#x2F; param2 &#x3D; world\n  \n  &#x2F;&#x2F; ?.运算符\n  var str1 &#x3D; &quot;hello world&quot;;\n  var str2 &#x3D; null;\n  print(str1?.length); &#x2F;&#x2F; 11\n  print(str2?.length); &#x2F;&#x2F; null \n  print(str2.length); &#x2F;&#x2F; 报错\n&#125;</code></pre>\n\n<h3 id=\"运算符（级联操作）\"><a href=\"#运算符（级联操作）\" class=\"headerlink\" title=\"..运算符（级联操作）\"></a>..运算符（级联操作）</h3><pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">class Person &#123;\n  eat() &#123;\n    print(&quot;I am eating...&quot;);\n  &#125;\n\n  sleep() &#123;\n    print(&quot;I am sleeping...&quot;);\n  &#125;\n\n  study() &#123;\n    print(&quot;I am studying...&quot;);\n  &#125;\n&#125;\n\nmain() &#123;\n  &#x2F;&#x2F; 依次打印\n  &#x2F;&#x2F;  I am eating...\n  &#x2F;&#x2F;  I am sleeping...\n  &#x2F;&#x2F;  I am studying...\n  new Person()..eat()\n      ..sleep()\n      ..study();\n&#125;</code></pre>\n\n<p>可以看到，使用..调用某个对象的方法（或者成员变量）时，返回值是这个对象本身，所以你可以接着使用..调用这个对象的其他方法，这不就类似于Java中的建造者模式，每次build某个属性时，都返回一个<strong>this</strong>对象。</p>\n<h2 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h2><h3 id=\"常规\"><a href=\"#常规\" class=\"headerlink\" title=\"常规\"></a>常规</h3><pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">main() &#123;\n  &#x2F;&#x2F; if else语句\n  int score &#x3D; 80;\n  if (score &lt; 60) &#123;\n    print(&quot;so bad!&quot;);\n  &#125; else if (score &gt;&#x3D; 60 &amp;&amp; score &lt; 80) &#123;\n    print(&quot;just so so!&quot;);\n  &#125; else if (score &gt;&#x3D; 80) &#123;\n    print(&quot;good job!&quot;);\n  &#125;\n\n  &#x2F;&#x2F; switch语句\n  String a &#x3D; &quot;hello&quot;;\n  &#x2F;&#x2F; case语句中的数据类型必须是跟switch中的类型一致\n  switch (a) &#123;\n    case &quot;hello&quot;:\n      print(&quot;haha&quot;);\n      break;\n    case &quot;world&quot;:\n      print(&quot;heihei&quot;);\n      break;\n    default:\n      print(&quot;WTF&quot;);\n  &#125;\n\n  &#x2F;&#x2F; for语句\n  List&lt;String&gt; list &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\n  for (int i &#x3D; 0; i &lt; list.length; i++) &#123;\n    print(list[i]);\n  &#125;\n  for (var i in list) &#123;\n    print(i);\n  &#125;\n  &#x2F;&#x2F; 这里的箭头函数参数必须用圆括号扩起来\n  list.forEach((item) &#x3D;&gt; print(item)); &#x2F;&#x2F;匿名函数\n\n  &#x2F;&#x2F; while语句\n  int start &#x3D; 1;\n  int sum &#x3D; 0;\n  while (start &lt;&#x3D; 100) &#123;\n    sum +&#x3D; start;\n    start++;\n  &#125;\n  print(sum);\n\n  &#x2F;&#x2F; try catch语句\n  try &#123;\n    print(1 ~&#x2F; 0);\n  &#125; catch (e) &#123;\n    &#x2F;&#x2F; IntegerDivisionByZeroException\n    print(e);\n  &#125;\n  try &#123;\n    1 ~&#x2F; 0;\n  &#125; on IntegerDivisionByZeroException &#123; &#x2F;&#x2F; 捕获指定类型的异常\n    print(&quot;error&quot;); &#x2F;&#x2F; 打印出error\n  &#125; finally &#123;\n    print(&quot;over&quot;); &#x2F;&#x2F; 打印出over\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"assert（断言）\"><a href=\"#assert（断言）\" class=\"headerlink\" title=\"assert（断言）\"></a>assert（断言）</h3><p>断言的作用是：如果表达式的求值结果不满足需要，则打断代码的执行。可以要将提示消息附加到断言，添加一个字符串作为第二个参数。</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">void main()\n&#123;\n    String urlString &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;;\n    assert(urlString.startsWith(&#39;https&#39;), &#39;URL ($urlString) should start with &quot;https&quot;.&#39;);\n    &#x2F;&#x2F; Failed assertion: &#39;urlString.startsWith(&#39;https&#39;)&#39;: URL (http:&#x2F;&#x2F;www.baidu.com) should start with &quot;https&quot;\n    &#x2F;&#x2F; 当urlString不是以https开头时，代码的执行会被打断\n    &#x2F;&#x2F; 当urlString是以https开头时，代码会继续执行\n&#125;</code></pre>\n\n<p>传入<strong>assert</strong>的参数，可以是任意表达式或者方法，只要返回值是<strong>bool</strong>就可以，当断言失败时（返回<strong>false</strong>），会抛出<strong>AssertionError</strong>异常。</p>\n<p><strong>注意:断言只有在检查模式下运行有效，在生产模式下是不会运行的。</strong></p>\n<h2 id=\"类（Class）\"><a href=\"#类（Class）\" class=\"headerlink\" title=\"类（Class）\"></a>类（Class）</h2><h3 id=\"类的定义与构造方法\"><a href=\"#类的定义与构造方法\" class=\"headerlink\" title=\"类的定义与构造方法\"></a>类的定义与构造方法</h3><p>Dart中的类没有访问控制，所以你不需要用<strong>private, protected, public</strong>等修饰成员变量或成员函数，一个简单的类如下代码所示：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">class Person &#123;\n  String name;\n  int age;\n  String gender;\n  Person(this.name, this.age, this.gender);\n  sayHello() &#123;\n    print(&quot;hello, this is $name, I am $age years old, I am a $gender&quot;);\n  &#125;\n&#125;</code></pre>\n\n<p>上面的<strong>Person</strong>类中有3个成员变量，一个构造方法和一个成员方法，看起来比较奇怪的是<strong>Person</strong>的构造方法，里面传入的3个参数都是<strong>this.xxx</strong>，而且没有大括号**{}**包裹的方法体，这种语法是Dart比较独特而简洁的构造方法声明方式，它等同于下面的代码：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">Person(String name, int age, String gender) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n    this.gender &#x3D; gender;\n&#125;</code></pre>\n\n<p>要调用<strong>Person</strong>类的成员变量或成员方法，可以用下面的代码。</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">var p &#x3D; new Person(&quot;zhangsan&quot;, 20, &quot;male&quot;);\np.sayHello(); &#x2F;&#x2F; hello, this is zhangsan, I am 20 years old, I am a male\np.age &#x3D; 50;\np.gender &#x3D; &quot;female&quot;;\np.sayHello(); &#x2F;&#x2F; hello, this is zhangsan, I am 50 years old, I am a female</code></pre>\n\n<p>类除了有跟类名相同的构造方法外，还可以添加<strong>命名的构造方法</strong>，如下代码所示：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">class Point &#123;\n  num x, y;区块中使用列表实例如下\n  Point(this.x, this.y);\n  &#x2F;&#x2F; 类的命名构造方法\n  Point.origin() &#123;\n    x &#x3D; 0;\n    y &#x3D; 0;\n  &#125;\n&#125;\n\nmain() &#123;\n  &#x2F;&#x2F; 调用Point类的命名构造方法origin()\n  var p &#x3D; new Point.origin();\n  var p2 &#x3D; new Point(1, 2);\n&#125;</code></pre>\n\n<h3 id=\"初始化列表\"><a href=\"#初始化列表\" class=\"headerlink\" title=\"初始化列表\"></a>初始化列表</h3><p>类似C/C++风格的初始化列表。</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">class Test1 &#123;\n  var x, y;\n  Test1(var x, var y) : x &#x3D; x, y &#x3D; y &#123;\n    print(&#39;Test1 有参构造初始化&#39;);\n  &#125;\n&#125;</code></pre>\n\n<p>在实际应用开发中，可以使用<strong>assert</strong>（断言）在初始化列表用来校验输入参数。</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">class Test1 &#123;\n  var x, y;\n\n  Test1(var x, var y) : assert(x &gt;&#x3D; 0) &#123;\n    print(&#39;Test1(): ($x, $y)&#39;);\n  &#125;\n&#125;</code></pre>\n\n<p><strong>assert</strong>（断言）的作用：如果表达式求值不满足需要，则打断代码的执行。</p>\n<h3 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h3><p>Dart中使用 <strong>extends</strong> 关键字做类的继承，如果一个类只有命名的构造方法，在继承时需要注意，如下代码：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">class Human &#123;\n  String name;\n  Human.fromJson(Map data) &#123;\n    print(&quot;Human&#39;s fromJson constructor&quot;);\n  &#125;\n&#125;\n\nclass Man extends Human &#123;\n  Man.fromJson(Map data) : super.fromJson(data) &#123;\n    print(&quot;Man&#39;s fromJson constructor&quot;);\n  &#125;\n&#125;</code></pre>\n\n<p>由于<strong>Human</strong>类没有默认构造方法，只有一个命名构造方法<strong>fromJson</strong>，所以在<strong>Man</strong>类继承<strong>Human</strong>类时，需要调用父类的<strong>fromJson</strong>方法做初始化，而且必须使用 <strong>Man.fromJson(Map data) : super.fromJson(data)</strong> 这种写法，而不是像Java那样将 <strong>super</strong> （指向父类）写到花括号中。</p>\n<p>使用 <strong>@override</strong> 注解声明你要重写的函数，在这个函数内部可以使用 <strong>super</strong> 调用重写的这个父类的函数。实现如下：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">class Test &#123;\n  void test() &#123;&#x2F;*这里省略方法内部的逻辑操作*&#x2F;&#125;\n  &#x2F;&#x2F; 其他逻辑\n&#125;\n\nclass TestChild extends Test &#123;\n  @override  &#x2F;&#x2F;@override标注在test()函数上面 表示test()函数是重写父类的。\n    void test() &#123;\n      super.test();&#x2F;&#x2F; 调用父类的test()函数\n      &#x2F;*这里省略方法内部的逻辑操作*&#x2F;\n    &#125;\n    &#x2F;&#x2F; 其他逻辑\n&#125;</code></pre>\n\n<h3 id=\"类的成员方法\"><a href=\"#类的成员方法\" class=\"headerlink\" title=\"类的成员方法\"></a>类的成员方法</h3><p>一个类的成员方法是一个函数，为这个类提供某些行为。上面的代码中已经有了一些类的成员方法的定义，这些定义方式跟Java很类似，你可以为某个类的成员变量提供<strong>getter/setter</strong>方法，如下代码：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">class Rectangle &#123;\n  num left, top, width, height;\n\n  &#x2F;&#x2F; 构造方法传入left, top, width, height几个参数\n  Rectangle(this.left, this.top, this.width, this.height);\n\n  &#x2F;&#x2F; right, bottom两个成员变量提供getter&#x2F;setter方法\n  num get right &#x3D;&gt; left + width;\n  set right(num value) &#x3D;&gt; left &#x3D; value - width;\n  num get bottom &#x3D;&gt; top + height;\n  set bottom(num value) &#x3D;&gt; top &#x3D; value - height;\n&#125;</code></pre>\n<p><strong>getter</strong>和<strong>setter</strong>是提供对象属性的<strong>读写访问</strong>的特殊方法。所有实例变量都生成一个隐式<strong>getter</strong>方法。<strong>非final</strong>实例变量也会生成隐式<strong>setter</strong>方法。使用<strong>get</strong>和<strong>set</strong>关键字通过实现<strong>getter</strong>和<strong>setter</strong>来创建其他属性。</p>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>静态方法：使用<strong>static</strong>关键字修饰的方法，也叫类方法，它不对实例进行操作，因此无权访问<strong>this</strong>。</p>\n<h3 id=\"抽象类和抽象方法\"><a href=\"#抽象类和抽象方法\" class=\"headerlink\" title=\"抽象类和抽象方法\"></a>抽象类和抽象方法</h3><p>使用abstract修饰一个类，则这个类是抽象类，抽象类中可以有抽象方法和非抽象方法，抽象方法没有方法体，需要子类去实现，如下代码：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">abstract class Doer &#123;\n  &#x2F;&#x2F; 抽象方法，没有方法体，需要子类去实现\n  void doSomething();\n  &#x2F;&#x2F; 普通的方法\n  void greet() &#123;\n    print(&quot;hello world!&quot;);\n  &#125;\n&#125;\n\nclass EffectiveDoer extends Doer &#123;\n  &#x2F;&#x2F; 实现了父类的抽象方法\n  void doSomething() &#123;\n    print(&quot;I&#39;m doing something...&quot;);\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h3><p>Dart中有类似于C++中的运算符重载语法，比如下面的代码定义了一个向量类，重载了向量的+ -运算：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">class Vector &#123;\n  num x, y;\n  Vector(this.x, this.y);\n  Vector operator +(Vector v) &#x3D;&gt; new Vector(x + v.x, y + v.y);\n  Vector operator -(Vector v) &#x3D;&gt; new Vector(x - v.x, y - v.y);\n  printVec() &#123;\n    print(&quot;x: $x, y: $y&quot;);\n  &#125;\n&#125;\n\nmain() &#123;\n  Vector v1 &#x3D; new Vector(1, 2);\n  Vector v2 &#x3D; new Vector(3, 4);\n  (v1 - v2).printVec(); &#x2F;&#x2F; -2, -2\n  (v1 + v2).printVec(); &#x2F;&#x2F; 4, 6\n&#125;</code></pre>\n<p>注意：**!=**不是可重写的运算符。</p>\n<h3 id=\"枚举类\"><a href=\"#枚举类\" class=\"headerlink\" title=\"枚举类\"></a>枚举类</h3><p>使用<strong>enum</strong>关键字声明枚举类型：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">enum Color &#123; red, green, blue &#125;</code></pre>\n\n<p>枚举中的每个值都有一个<strong>index getter</strong>，它返回枚举声明中值的从零开始的位置。例如，<strong>第一个值具有索引0，第二个值具有索引1</strong>。</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">assert(Color.red.index &#x3D;&#x3D; 0);\nassert(Color.green.index &#x3D;&#x3D; 1);\nassert(Color.blue.index &#x3D;&#x3D; 2);</code></pre>\n\n<p>在实际应用开发中，可以使用<strong>assert</strong>在初始化列表用来校验输入参数。</p>\n<p>要获取枚举中所有值的列表，请使用枚举<strong>values</strong>常量。</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">List&lt;Color&gt; colors &#x3D; Color.values;\nassert(colors[2] &#x3D;&#x3D; Color.blue);</code></pre>\n\n<p>可以在 <strong>switch</strong> 语句中使用枚举，如果你不处理所有枚举值，你将收到警告。</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">var aColor &#x3D; Color.blue;\nswitch (aColor) &#123;\n  case Color.red:\n    print(&#39;Red&#39;);\n    break;\n  case Color.green:\n    print(&#39;Green&#39;);\n    break;\n  default: &#x2F;&#x2F; 你没有这个 你会看到一个警告\n    print(aColor); &#x2F;&#x2F; &#39;Color.blue&#39;\n&#125;</code></pre>\n<h3 id=\"静态成员变量和静态成员方法\"><a href=\"#静态成员变量和静态成员方法\" class=\"headerlink\" title=\"静态成员变量和静态成员方法\"></a>静态成员变量和静态成员方法</h3><pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">&#x2F;&#x2F; 类的静态成员变量和静态成员方法\nclass Cons &#123;\n  static const name &#x3D; &quot;zhangsan&quot;;\n  static sayHello() &#123;\n    print(&quot;hello, this is $&#123;Cons.name&#125;&quot;);\n  &#125;\n&#125;\n\nmain() &#123;\n  Cons.sayHello(); &#x2F;&#x2F; hello, this is zhangsan\n  print(Cons.name); &#x2F;&#x2F; zhangsan\n&#125;</code></pre>\n\n<h3 id=\"mixins\"><a href=\"#mixins\" class=\"headerlink\" title=\"mixins\"></a>mixins</h3><p>mixins是一个重复使用类中代码的方式，比如下面的代码：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">class A &#123;\n  a() &#123;\n    print(&quot;A&#39;s a()&quot;);\n  &#125;\n&#125;\n\nclass B &#123;\n  b() &#123;\n    print(&quot;B&#39;s b()&quot;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用with关键字，表示类C是由类A和类B混合而构成\nclass C &#x3D; A with B;\n\nmain() &#123;\n  C c &#x3D; new C();\n  c.a(); &#x2F;&#x2F; A&#39;s a()\n  c.b(); &#x2F;&#x2F; B&#39;s b()\n&#125;</code></pre>\n\n<h2 id=\"泛型（Generics）\"><a href=\"#泛型（Generics）\" class=\"headerlink\" title=\"泛型（Generics）\"></a>泛型（Generics）</h2><p>正确指定泛型类型会产生更好的生成代码。泛型可以减小代码的复杂度。</p>\n<p>Dart内置的数据类型List就是一个泛型数据类型，你可以往<strong>List</strong>中塞任何你想的数据类型比如整型、字符串、布尔值等。</p>\n<p> 当然，如果您希望列表只包含字符串，则可以将其声明为**List&lt;String&gt;**（字符串列表）。这样一来，工具可以检测到将非字符串分配给列表可能是一个错误。</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">var names &#x3D; List&lt;String&gt;();\nnames.addAll([&#39;Seth&#39;, &#39;Kathy&#39;, &#39;Lars&#39;]);\n&#x2F;&#x2F; 报错 The argument type &#39;int&#39; can&#39;t be assigned to the parameter type &#39;String&#39;.\nnames.add(42); </code></pre>\n\n<p>泛型允许你在多种类型之间共享单个接口和实现，同时仍然利用静态分析。你可以创建一个带有类型参数的接口。示例如下：T是一个占位符，你可以将其视为开发人员稍后定义的类型。</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">abstract class Cache&lt;T&gt; &#123;\n  T getByKey(String key);\n&#125;</code></pre>\n\n<h2 id=\"Dart库（Libraries）\"><a href=\"#Dart库（Libraries）\" class=\"headerlink\" title=\"Dart库（Libraries）\"></a>Dart库（Libraries）</h2><p>Dart目前已经有很多的库提供给开发者，许多功能不需要开发者自己去实现，只需要导入对应的包即可，使用<strong>import</strong>语句来导入某个包，比如下面的代码：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">import &#39;dart:html&#39;;</code></pre>\n\n<p>如果你想导入自己写的某个代码文件，使用相对路径即可，例如当前有一个<strong>demo.dart</strong>文件，跟该文件同级目录下有个<strong>util.dart</strong>文件，文件代码如下：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">&#x2F;&#x2F; util.dart文件内容\n\nint add(int a, int b) &#123;\n  return a + b;\n&#125;</code></pre>\n\n<p>在<strong>demo.dart</strong>文件中如果要引用<strong>util.dart</strong>文件，使用下面的方式导入：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">&#x2F;&#x2F; demo.dart\n\nimport &#39;.&#x2F;util.dart&#39;;\n\nmain() &#123;\n  print(add(1, 2));\n&#125;</code></pre>\n\n<p>你可以使用<strong>as</strong>关键字为导入的某个包设置一个前缀，或者说别名，比如下面的代码：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">import &#39;package:lib1&#x2F;lib1.dart&#39;;\nimport &#39;package:lib2&#x2F;lib2.dart&#39; as lib2;\n\n&#x2F;&#x2F; Uses Element from lib1.\nElement element1 &#x3D; Element();\n\n&#x2F;&#x2F; Uses Element from lib2.\nlib2.Element element2 &#x3D; lib2.Element();</code></pre>\n\n<p>你也可以在导入包时使用<strong>show, hide</strong>关键字来导入某个包中的部分功能，比如下面的代码：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">&#x2F;&#x2F; 只导入foo\nimport &#39;package:lib1&#x2F;lib1.dart&#39; show foo;\n\n&#x2F;&#x2F; 导入除了foo的所有其他部分\nimport &#39;package:lib2&#x2F;lib2.dart&#39; hide foo;</code></pre>\n\n<p>导入包时使用<strong>deferred as</strong>可以让这个包懒加载，懒加载的包只会在该包被使用时得到加载，而不是一开始就加载，比如下面的代码：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">import &#39;package:greetings&#x2F;hello.dart&#39; deferred as hello;</code></pre>\n\n<h2 id=\"异步支持\"><a href=\"#异步支持\" class=\"headerlink\" title=\"异步支持\"></a>异步支持</h2><p>Dart类库有非常多的返回Future或者Stream对象的函数。 这些函数被称为异步函数：它们只会在设置好一些耗时操作之后返回，比如像 IO操作。而不是等到这个操作完成。</p>\n<p>async和await关键词支持了异步编程，允许您写出和同步代码很像的异步代码。</p>\n<h3 id=\"Future\"><a href=\"#Future\" class=\"headerlink\" title=\"Future\"></a>Future</h3><p>Future与JavaScript中的Promise非常相似，表示一个异步操作的最终完成（或失败）及其结果值的表示。简单来说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。一个Future只会对应一个结果，要么成功，要么失败。</p>\n<p>由于本身功能较多，这里我们只介绍其常用的API及特性。还有，请记住，Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用。</p>\n<h4 id=\"Future-then\"><a href=\"#Future-then\" class=\"headerlink\" title=\"Future.then\"></a>Future.then</h4><p>为了方便示例，在本例中我们使用<strong>Future.delayed</strong>创建了一个延时任务（实际场景会是一个真正的耗时任务，比如一次网络请求），即2秒后返回结果字符串”hi world!”，然后我们在<strong>then</strong>中接收异步结果并打印结果，代码如下：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">main() &#123;\n  Future.delayed(new Duration(seconds: 2),()&#123;\n    return &quot;hi world!&quot;;\n  &#125;).then((data)&#123;\n    print(data);\n  &#125;);\n&#125;</code></pre>\n\n<h4 id=\"Future-catchError\"><a href=\"#Future-catchError\" class=\"headerlink\" title=\"Future.catchError\"></a>Future.catchError</h4><p>如果异步任务发生错误，我们可以在<strong>catchError</strong>中捕获错误，我们将上面示例改为：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">main() &#123;\n  Future.delayed(new Duration(seconds: 2),()&#123;\n    &#x2F;&#x2F;return &quot;hi world!&quot;;\n    throw AssertionError(&quot;Error&quot;);\n  &#125;).then((data)&#123;\n    &#x2F;&#x2F;执行成功会走到这里\n    print(&quot;success&quot;);\n  &#125;).catchError((e)&#123;\n    &#x2F;&#x2F;执行失败会走到这里\n    print(e);\n  &#125;);\n&#125;</code></pre>\n\n<p>在本示例中，我们在异步任务中抛出了一个异常，<strong>then</strong>的回调函数将不会被执行，取而代之的是<strong>catchError</strong>回调函数将被调用；但是，并不是只有<strong>catchError</strong>回调才能捕获错误，<strong>then</strong>方法还有一个可选参数<strong>onError</strong>，我们也可以它来捕获异常：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">main() &#123;\n  Future.delayed(new Duration(seconds: 2), () &#123;\n      &#x2F;&#x2F;return &quot;hi world!&quot;;\n      throw AssertionError(&quot;Error&quot;);\n  &#125;).then((data) &#123;\n      print(&quot;success&quot;);\n  &#125;, onError: (e) &#123;\n      print(e);\n  &#125;);\n&#125;</code></pre>\n\n<h4 id=\"Future-whenComplete\"><a href=\"#Future-whenComplete\" class=\"headerlink\" title=\"Future.whenComplete\"></a>Future.whenComplete</h4><p>有些时候，我们会遇到无论异步任务执行成功或失败都需要做一些事的场景，比如在网络请求前弹出加载对话框，在请求结束后关闭对话框。这种场景，有两种方法，第一种是分别在<strong>then</strong>或<strong>catch</strong>中关闭一下对话框，第二种就是使用<strong>Future</strong>的<strong>whenComplete</strong>回调，我们将上面示例改一下：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">main() &#123;\n  Future.delayed(new Duration(seconds: 2),()&#123;\n    &#x2F;&#x2F;return &quot;hi world!&quot;;\n    throw AssertionError(&quot;Error&quot;);\n  &#125;).then((data)&#123;\n    &#x2F;&#x2F;执行成功会走到这里\n    print(data);\n  &#125;).catchError((e)&#123;\n    &#x2F;&#x2F;执行失败会走到这里\n    print(e);\n  &#125;).whenComplete(()&#123;\n    &#x2F;&#x2F;无论成功或失败都会走到这里\n  &#125;);\n&#125;</code></pre>\n\n<h4 id=\"Future-wait\"><a href=\"#Future-wait\" class=\"headerlink\" title=\"Future.wait\"></a>Future.wait</h4><p>有些时候，我们需要等待多个异步任务都执行结束后才进行一些操作，比如我们有一个界面，需要先分别从两个网络接口获取数据，获取成功后，我们需要将两个接口数据进行特定的处理后再显示到UI界面上，应该怎么做？答案是<strong>Future.wait</strong>，它接受一个<strong>Future</strong>数组参数，只有数组中所有<strong>Future</strong>都执行成功后，才会触发<strong>then</strong>的成功回调，只要有一个<strong>Future</strong>执行失败，就会触发错误回调。下面，我们通过模拟<strong>Future.delayed</strong>来模拟两个数据获取的异步任务，等两个异步任务都执行成功时，将两个异步任务的结果拼接打印出来，代码如下：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">main() &#123;\n  Future.wait([\n    &#x2F;&#x2F; 2秒后返回结果\n    Future.delayed(new Duration(seconds: 2), () &#123;\n        return &quot;hello&quot;;\n      &#125;),\n    &#x2F;&#x2F; 4秒后返回结果\n    Future.delayed(new Duration(seconds: 4), () &#123;\n        return &quot; world&quot;;\n      &#125;)\n  ]).then((results)&#123;\n    print(results[0]+results[1]);\n  &#125;).catchError((e)&#123;\n    print(e);\n  &#125;);\n&#125;</code></pre>\n\n<p>执行上面代码，4秒后你会在控制台中看到“hello world”。</p>\n<h3 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h3><p><strong>Dart</strong>中的<strong>async/await</strong>和<strong>JavaScript</strong>中的<strong>async/await</strong>功能和用法是一模一样的。</p>\n<h4 id=\"回调地狱-Callback-Hell\"><a href=\"#回调地狱-Callback-Hell\" class=\"headerlink\" title=\"回调地狱(Callback Hell)\"></a>回调地狱(Callback Hell)</h4><p>如果代码中有大量异步逻辑，并且出现大量异步任务依赖其它异步任务的结果时，必然会出现<strong>Future.then</strong>回调中套回调情况。举个例子，比如现在有个需求场景是用户先登录，登录成功后会获得用户ID，然后通过用户ID，再去请求用户个人信息，获取到用户个人信息后，为了使用方便，我们需要将其缓存在本地文件系统，代码如下：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">&#x2F;&#x2F;先分别定义各个异步任务\nFuture&lt;String&gt; login(String userName, String pwd)&#123;\n    ...\n    &#x2F;&#x2F;用户登录\n&#125;;\nFuture&lt;String&gt; getUserInfo(String id)&#123;\n    ...\n    &#x2F;&#x2F;获取用户信息\n&#125;;\nFuture saveUserInfo(String userInfo)&#123;\n    ...\n    &#x2F;&#x2F; 保存用户信息\n&#125;;</code></pre>\n\n<p>接下来，执行整个任务流：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">login(&quot;alice&quot;,&quot;******&quot;).then((id)&#123;\n  &#x2F;&#x2F;登录成功后通过，id获取用户信息\n  getUserInfo(id).then((userInfo)&#123;\n    &#x2F;&#x2F;获取用户信息后保存\n    saveUserInfo(userInfo).then(()&#123;\n       &#x2F;&#x2F;保存用户信息，接下来执行其它操作\n        ...\n    &#125;);\n  &#125;);\n&#125;)</code></pre>\n\n<p>可以感受一下，如果业务逻辑中有大量异步依赖的情况，将会出现上面这种在回调里面套回调的情况，过多的嵌套会导致的代码可读性下降以及出错率提高，并且非常难维护，这个问题被形象的称为回调地狱（Callback Hell）。回调地狱问题在之前JavaScript中非常突出，也是JavaScript被吐槽最多的点，但随着ECMAScript6和ECMAScript7标准发布后，这个问题得到了非常好的解决，而解决回调地狱的两大神器正是ECMAScript6引入了Promise，以及ECMAScript7中引入的async/await。 而在Dart中几乎是完全平移了JavaScript中的这两者：Future相当于Promise，而async/await连名字都没改。接下来我们看看通过Future和async/await如何消除上面示例中的嵌套问题。</p>\n<h4 id=\"使用Future消除Callback-Hell\"><a href=\"#使用Future消除Callback-Hell\" class=\"headerlink\" title=\"使用Future消除Callback Hell\"></a>使用Future消除Callback Hell</h4><pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">login(&quot;alice&quot;,&quot;******&quot;).then((id)&#123;\n      return getUserInfo(id);\n&#125;).then((userInfo)&#123;\n    return saveUserInfo(userInfo);\n&#125;).then((e)&#123;\n  &#x2F;&#x2F;执行接下来的操\n&#125;).catchError((e)&#123;\n  &#x2F;&#x2F;错误处理\n  print(e);\n&#125;);</code></pre>\n\n<p>正如上文所述， “<strong>Future</strong>的所有API的返回值仍然是一个<strong>Future</strong>对象，所以可以很方便的进行链式调用”，如果在<strong>then</strong>中返回的是一个<strong>Future</strong>的话，该<strong>Future</strong>会执行，执行结束后会触发后面的<strong>then</strong>回调，这样依次向下，就避免了层层嵌套。</p>\n<h4 id=\"使用async-await消除callback-hell\"><a href=\"#使用async-await消除callback-hell\" class=\"headerlink\" title=\"使用async/await消除callback hell\"></a>使用async/await消除callback hell</h4><p>通过<strong>Future</strong>回调中再返回<strong>Future</strong>的方式虽然能避免层层嵌套，但是还是有一层回调，有没有一种方式能够让我们可以像写同步代码那样来执行异步任务而不使用回调的方式？答案是肯定的，这就要使用<strong>async/await</strong>了，下面我们先直接看代码，然后再解释，代码如下：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">task() async &#123;\n  try&#123;\n    String id &#x3D; await login(&quot;alice&quot;,&quot;******&quot;);\n    String userInfo &#x3D; await getUserInfo(id);\n    await saveUserInfo(userInfo);\n    &#x2F;&#x2F;执行接下来的操作\n  &#125; catch(e)&#123;\n    &#x2F;&#x2F;错误处理\n    print(e);\n  &#125;\n&#125;</code></pre>\n\n<ul>\n<li><strong>async</strong>用来表示函数是异步的，定义的函数会返回一个<strong>Future</strong>对象，可以使用<strong>then</strong>方法添加回调函数。</li>\n<li><strong>await</strong>后面是一个<strong>Future</strong>，表示等待该异步任务完成，异步完成后才会往下走；<strong>await</strong>必须出现在<strong>async</strong>函数内部。</li>\n</ul>\n<p>可以看到，我们通过<strong>async/await</strong>将一个异步流用同步的代码表示出来了。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>其实，无论是在JavaScript还是Dart中，async/await都只是一个语法糖，编译器或解释器最终都会将其转化为一个Promise（Future）的调用链。</p></blockquote>\n<h3 id=\"Stream\"><a href=\"#Stream\" class=\"headerlink\" title=\"Stream\"></a>Stream</h3><p>Stream也是用于接收异步事件数据，和Future不同的是，它可以接收多个异步操作的结果（成功或失败）。 也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 Stream 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子：</p>\n<pre class=\"line-numbers language-dart\" data-language=\"dart\"><code class=\"language-dart\">main() &#123;\n  Stream.fromFutures([\n    &#x2F;&#x2F; 1秒后返回结果\n    Future.delayed(new Duration(seconds: 1), () &#123;\n        return &quot;hello 1&quot;;\n      &#125;),\n    &#x2F;&#x2F; 抛出一个异常\n    Future.delayed(new Duration(seconds: 2),()&#123;\n        throw AssertionError(&quot;Error&quot;);\n      &#125;),\n    &#x2F;&#x2F; 3秒后返回结果\n    Future.delayed(new Duration(seconds: 3), () &#123;\n        return &quot;hello 3&quot;;\n      &#125;)\n  ]).listen((data)&#123;\n    print(data);\n  &#125;, onError: (e)&#123;\n    print(e.message);\n  &#125;,onDone: ()&#123;\n\n  &#125;);\n&#125;</code></pre>\n\n<p>上面的代码依次会输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">I&#x2F;flutter (17666): hello 1\nI&#x2F;flutter (17666): Error\nI&#x2F;flutter (17666): hello 3</code></pre>\n\n<h2 id=\"Dart和Java及JavaScript对比\"><a href=\"#Dart和Java及JavaScript对比\" class=\"headerlink\" title=\"Dart和Java及JavaScript对比\"></a>Dart和Java及JavaScript对比</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>之所以将Dart与Java和JavaScript对比，是因为，这两者分别是强类型语言和弱类型语言的典型代表，并且Dart 语法中很多地方也都借鉴了Java和JavaScript。</p></blockquote>\n<h3 id=\"Dart-vs-Java\"><a href=\"#Dart-vs-Java\" class=\"headerlink\" title=\"Dart vs Java\"></a>Dart vs Java</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>客观的来讲，Dart在语法层面确实比Java更有表现力；在VM层面，Dart VM在内存回收和吞吐量都进行了反复的优化，但具体的性能对比，笔者没有找到相关测试数据，但在笔者看来，只要Dart语言能流行，VM的性能就不用担心，毕竟Google在Go（没用VM但有GC）、JavaScript（v8）、Dalvik（Android上的Java VM）上已经有了很多技术积淀。值得注意的是Dart在Flutter中已经可以将GC做到10ms以内，所以Dart和Java相比，决胜因素并不会是在性能方面。而在语法层面，Dart要比Java更有表现力，最重要的是Dart对函数式编程支持要远强于Java(目前只停留在Lambda表达式)，而Dart目前真正的不足是生态，但笔者相信，随着Flutter的逐渐火热，会回过头来反推Dart生态加速发展，对于Dart来说，现在需要的是时间。</p></blockquote>\n<h3 id=\"Dart-vs-JavaScript\"><a href=\"#Dart-vs-JavaScript\" class=\"headerlink\" title=\"Dart vs JavaScript\"></a>Dart vs JavaScript</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>JavaScript的弱类型一直被抓短，所以TypeScript、CoffeeScript甚至是Facebook的flow（虽然并不能算JavaScript的一个超集，但也通过标注和打包工具提供了静态类型检查）才有市场。就笔者使用过的脚本语言中（笔者曾使用过Python、PHP），JavaScript无疑是动态化支持最好的脚本语言，比如在JavaScript中，可以给任何对象在任何时候动态扩展属性，对于精通JavaScript的高手来说，这无疑是一把利剑。但是，任何事物都有两面性，JavaScript的强大的动态化特性也是把双刃剑，你可经常听到另一个声音，认为JavaScript的这种动态性糟糕透了，太过灵活反而导致代码很难预期，无法限制不被期望的修改。毕竟有些人总是对自己或别人写的代码不放心，他们希望能够让代码变得可控，并期望有一套静态类型检查系统来帮助自己减少错误。正因如此，在Flutter中，Dart几乎放弃了脚本语言动态化的特性，如不支持反射、也不支持动态创建函数等。并且Dart在2.0强制开启了类型检查（Strong Mode），原先的检查模式（checked mode）和可选类型（optional type）将淡出，所以在类型安全这个层面来说，Dart和TypeScript、CoffeeScript是差不多的，所以单从这一点来看，Dart并不具备什么明显优势，但综合起来看，Dart既能进行服务端脚本、APP开发、web开发，这就有优势了！</p></blockquote>\n<h2 id=\"参考引用\"><a href=\"#参考引用\" class=\"headerlink\" title=\"参考引用\"></a>参考引用</h2><p>本文大量学习借鉴了以下文章</p>\n<p>《Dart的语法详解系列篇（二）– 类与函数》 作者：<strong>AWeiLoveAndroid</strong> 链接：<a href=\"https://www.jianshu.com/p/44ae73a58ebc\">https://www.jianshu.com/p/44ae73a58ebc</a></p>\n<p>《30分钟掌握Dart语言》 作者：<strong>彡廿</strong> 链接：<a href=\"https://www.jianshu.com/p/06aebcad0543\">https://www.jianshu.com/p/06aebcad0543</a></p>\n<p>《Dart语言简介》 出处 <strong>Flutter中文网</strong> 链接：<a href=\"https://book.flutterchina.club/chapter1/dart.html\">https://book.flutterchina.club/chapter1/dart.html</a></p>\n<p>《Dart 断言(assert)和异常》 作者：<strong>name不是null</strong> 链接：<a href=\"https://www.jianshu.com/p/7c5c0a1f118a\">https://www.jianshu.com/p/7c5c0a1f118a</a></p>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><ul>\n<li>作者：麟子</li>\n<li>地址：<a href=\"https://swz128.top/post/Dart\">https://swz128.top/post/Dart</a></li>\n<li>协议：<a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\">CC BY-SA 4.0</a> 欢迎转载，务必注明出处</li>\n</ul>\n","text":"Dart 学习总结本文大量学习借鉴了 「AWeiLoveAndroid」、 「name不是null」 与 「彡廿」 的博文和 「Flutter中文网」 的入门指南，在此表示感谢，被引用文章链接见文末 1.变量可以用C\\C++风格的方式声明变量，如int, bool, String...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"22 mins."},"categories":[{"name":"教程","slug":"教程","count":3,"path":"api/categories/教程.json"}],"tags":[{"name":"Dart","slug":"Dart","count":1,"path":"api/tags/Dart.json"},{"name":"学习","slug":"学习","count":1,"path":"api/tags/学习.json"},{"name":"教程","slug":"教程","count":1,"path":"api/tags/教程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Dart-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">Dart 学习总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">1.变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">函数返回值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E9%80%89%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">可选的命名参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E9%80%89%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">可选的位置参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC\"><span class=\"toc-text\">参数默认值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">函数作为变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">函数作为参数传递</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%88%AB%E5%90%8D\"><span class=\"toc-text\">函数别名</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">运算符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6-1\"><span class=\"toc-text\">运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C%EF%BC%89\"><span class=\"toc-text\">..运算符（级联操作）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">流程控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%84\"><span class=\"toc-text\">常规</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#assert%EF%BC%88%E6%96%AD%E8%A8%80%EF%BC%89\"><span class=\"toc-text\">assert（断言）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%EF%BC%88Class%EF%BC%89\"><span class=\"toc-text\">类（Class）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">类的定义与构造方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">初始化列表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">类的继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">类的成员方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">静态方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">抽象类和抽象方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">运算符重载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE%E7%B1%BB\"><span class=\"toc-text\">枚举类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">静态成员变量和静态成员方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mixins\"><span class=\"toc-text\">mixins</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%EF%BC%88Generics%EF%BC%89\"><span class=\"toc-text\">泛型（Generics）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Dart%E5%BA%93%EF%BC%88Libraries%EF%BC%89\"><span class=\"toc-text\">Dart库（Libraries）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">异步支持</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Future\"><span class=\"toc-text\">Future</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Future-then\"><span class=\"toc-text\">Future.then</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Future-catchError\"><span class=\"toc-text\">Future.catchError</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Future-whenComplete\"><span class=\"toc-text\">Future.whenComplete</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Future-wait\"><span class=\"toc-text\">Future.wait</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#async-await\"><span class=\"toc-text\">async&#x2F;await</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1-Callback-Hell\"><span class=\"toc-text\">回调地狱(Callback Hell)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8Future%E6%B6%88%E9%99%A4Callback-Hell\"><span class=\"toc-text\">使用Future消除Callback Hell</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8async-await%E6%B6%88%E9%99%A4callback-hell\"><span class=\"toc-text\">使用async&#x2F;await消除callback hell</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Stream\"><span class=\"toc-text\">Stream</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Dart%E5%92%8CJava%E5%8F%8AJavaScript%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">Dart和Java及JavaScript对比</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Dart-vs-Java\"><span class=\"toc-text\">Dart vs Java</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Dart-vs-JavaScript\"><span class=\"toc-text\">Dart vs JavaScript</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">参考引用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">版权声明</span></a></li></ol></li></ol>","author":{"name":"麟子","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"摸鱼➕摸鱼<br><a style=color:green>Email:</a> swz12306@gmail.com","socials":{"github":"https://github.com/swz128","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/yang-zheng-lin-32","csdn":"","juejin":"","customs":{"rss":{"icon":"/images/RSS.svg","link":"https://swz128.top/atom.xml"}}}},"mapped":true,"prev_post":{"title":"基于容器（docker）的 WRF模式 简易快速部署方案","uid":"03ab3527d41f8e0cc6ed204543909849","slug":"easy-wrf","date":"2020-09-30T16:00:00.000Z","updated":"2020-09-30T16:00:00.000Z","comments":true,"path":"api/articles/easy-wrf.json","keywords":"Linux, LaTeX, Blog","cover":"https://img.swz128.top/EASY-WRF_File/logo.png","text":" Easy-WRF WRF（Weather Research and Forecasting Model）模式是由NCEP，NCAR等科研机构中心着手开发的一种统一的中尺度天气预报模式。WRF模式系统具有的可移植，易维护，可扩充，高效率，方便等特点，使其成为改进从云尺度到各种不同...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"项目","slug":"项目","count":2,"path":"api/categories/项目.json"}],"tags":[{"name":"docker","slug":"docker","count":1,"path":"api/tags/docker.json"},{"name":"WRF模式","slug":"WRF模式","count":1,"path":"api/tags/WRF模式.json"},{"name":"安装","slug":"安装","count":1,"path":"api/tags/安装.json"},{"name":"easy-wrf","slug":"easy-wrf","count":1,"path":"api/tags/easy-wrf.json"}],"author":{"name":"麟子","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"摸鱼➕摸鱼<br><a style=color:green>Email:</a> swz12306@gmail.com","socials":{"github":"https://github.com/swz128","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/yang-zheng-lin-32","csdn":"","juejin":"","customs":{"rss":{"icon":"/images/RSS.svg","link":"https://swz128.top/atom.xml"}}}}},"next_post":{}}