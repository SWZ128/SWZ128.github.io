[{"id":"c610368769f12787a9bf7ccd858f26bb","title":"Node.js 学习记录 Day-01","content":"Node.js 学习 Day-011.1 What is Node.js\n\n\n\n\n\n\n\n\nNode.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.\n\nNode.js 不是语言\nNode.js 不是库, 不是框架\nNode.js 是一个 JavaScript 运行时环境\nNode.js 可以解析和运行 js 代码\n脱离浏览器\n\n\n浏览器中的 JavaScript\nEcmaScript\n基本语法(if,var,function,object…)\n\n\nBOM\nDOM\n\nNode.js 中的 JavaScript\n不包含 BOM,DOM\nEcmaScript\nNode.js 为 JavaScript 提供了一些服务器级别的 API\n文件的读写\n进程管理\n网络服务的构建\n\n\n构建于 Chrome 的 V8 引擎之上\nGoogle Chrome 的 V8 引擎是目前公认最快的 JavaScript 代码解析执行引擎\n\n\n\nFeature\n事件驱动\n非阻塞 I/O 模型(异步)\n轻量高效\nnpm 包管理器, 世界上最大的开源生态库\n\n1.2 Node.js 能做什么\nWeb 服务器后台\n命令行工具\n\n1.3 参考资料\n《七天学会 Node.js》 http://nqdeng.github.io/7-days-nodejs/\nNode.js 中文网入门教程 http://nodejs.cn/learn\nNode.js 黑马程序员 https://www.bilibili.com/video/BV1Ns411N7HU\n\n1.4 你将会收获\nB/S 编程\nBrowser-Server\n\n\nNode 常用的 API\n异步编程\n回调函数\nPromise\nasync\ngenerator\n\n\nExpress Web 开发\nEcmaScript 6\n打开服务端黑盒, 帮助学习其他前端高级内容\nVue.js\nReact\nangular\n\n\n\n1.5 安装 Node.js\n菜鸟教程 https://www.runoob.com/nodejs/nodejs-install-setup.html\nNode.js 中文网 http://nodejs.cn/\nNode.js 官网 https://nodejs.org/en/\n\n1.6 HelloWorldHelloWorld\nvar foo &#x3D; &#39;bar&#39;\nconsole.log(foo)\n\nfs 是 file-system 的简写, 就是文件系統的意思在 Node.js 中如果想要进行文件操作, 就必需加载 fs 这个核心模块\n在 fs 这个核心模块中, 就提供一所有的文件操作相关的 API例如: fs.readFile 就是用来读取文任的\n&#x2F;&#x2F; 使用 require 方法来加载 fs 模块\nvar fs &#x3D; require(&#39;fs&#39;)\n&#x2F;&#x2F; 或者\n&#x2F;&#x2F; import fs from &#39;fs&#39;;  &#x2F;&#x2F;ES6\n\nfs.readFile(&#39;Hello.txt&#39;, (error, data) &#x3D;&gt; &#123;\n    if (error) &#123;\n        console.log(&#39;Error&#39;)\n    &#125; else &#123;\n        &#x2F;&#x2F; 或者\n        &#x2F;&#x2F; console.log(&#39;%s&#39;, data);\n        console.log(data.toString());\n    &#125;\n&#125;);\nout:\nHelloWorld!\n你好, Node.js\n\nfs.writeFile 写文件\nvar fs &#x3D; require(&#39;fs&#39;);\n\nfs.writeFile(&#39;.&#x2F;output.txt&#39;, &#39;你好, 我是 Node.js&#39;, (error) &#x3D;&gt; &#123;\n    if (error) &#123;\n        console.log(&#39;Error&#39;)\n    &#125; else &#123;\n        console.log(&#39;success&#39;)\n    &#125;\n&#125;);\nout:\nsuccess\n\n1.7 实现简单的 http 服务var http &#x3D; require(&#39;http&#39;)\n\nvar server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 注册 request 请求事件\n&#x2F;&#x2F; 当接收到客户端的请求, 触发服务器的 request 请求事件然后执行第二个参数: 回调处理函数\nserver.on(&#39;request&#39;, () &#x3D;&gt; &#123;\n    console.log(&#39;收的请求&#39;)\n&#125;)\n\n&#x2F;&#x2F; 绑定端口, 启动服务\nserver.listen(3000, () &#x3D;&gt; &#123;\n    console.log(&#39;Success, open http:&#x2F;&#x2F;localhost:3000&#39;)\n&#125;)\n\nrequest 请求事件处理函数, 需要接收两个参数\n\nRequest 请求对象\n可以用来获取客户端的请求信息, 比如请求路径\n\n\nResponse 响应对象\n可以用来给客户端发送响应消息\n\n\n\nvar http &#x3D; require(&#39;http&#39;)\n\nvar server &#x3D; http.createServer()\n\n&#x2F;&#x2F; 注册 request 请求事件\n&#x2F;&#x2F; 当接收到客户端的请求, 触发服务器的 request 请求事件然后执行第二个参数: 回调处理函数\nserver.on(&#39;request&#39;, (request, response) &#x3D;&gt; &#123;\n    console.log(&#39;收的请求, 请求路径是: &#39; + request.url)\n\n    &#x2F;&#x2F; response 有个方法 response.write, 可以给客户端发送消息\n    &#x2F;&#x2F; write 可以使用多次, 但是最后一定要使用 end 结束, 否则客户端会一直等待\n    response.write(&#39;Hello&#39;)\n    response.write(&#39;  Node.js&#39;)\n\n    &#x2F;&#x2F; 结束响应\n    response.end()\n&#125;)\n\n&#x2F;&#x2F; 绑定端口, 启动服务\nserver.listen(3000, () &#x3D;&gt; &#123;\n    console.log(&#39;Success, open http:&#x2F;&#x2F;localhost:3000&#39;)\n&#125;)\n\n版权声明\n作者：麟子\n地址：https://swz128.top/post/Nodejs-01\n协议：CC BY-SA 4.0 欢迎转载，务必注明出处\n\n","slug":"Nodejs-01","date":"2021-11-08T16:00:00.000Z","categories_index":"教程","tags_index":"Node.js,JavaScript","author_index":"麟子"},{"id":"efcb3872a8238a8c164485d15c4f6cee","title":"获取 半次元(https://bcy.net/) 无水印原图","content":"BCY原图用于获取半次元无水印原图的Tampermonkey脚本\n因为一些原因需要下载半次元的原图，用了一些其他人写的脚本，发现有些地方不满足需求，于是参考前辈们的作品写了一个脚本。在此开源分享：\nGitHub: https://github.com/SWZ128/BCY\n安装\n在浏览器中安装油猴插件https://www.tampermonkey.net/\n\n\n\n\n\n\n\n\n\n\nTampermonkey 是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome, Microsoft Edge, Safari, Opera Next, 和 Firefox。\n\n从 Greasy Fork 中安装本脚本https://greasyfork.org/zh-CN/scripts/434023\n\n使用启用该脚本后，在图片下方会出现一个「查看原图」的超链接，点击可打开查看相应图片的无水印原图。\n原图 另存为 之后，文件名后缀为 xxx.image ，需要重名名为 xxx.jpg 。\n鸣谢\n半次元获取原图\n\n插件地址： https://greasyfork.org/zh-CN/scripts/390830\n\n\n显示半次元（bcy.net）图片的大图url（下载辅助）\n\n插件地址： https://greasyfork.org/zh-CN/scripts/23336\n\n\n\nLicenseMIT License\n版权声明\n作者：麟子\n地址：https://swz128.top/post/BCY\n协议：CC BY-SA 4.0 欢迎转载，务必注明出处\n\n","slug":"BCY","date":"2021-09-30T16:00:00.000Z","categories_index":"项目","tags_index":"油猴,脚本,Chrome,Firefox,Tampermonkey,半次元","author_index":"麟子"},{"id":"03ab3527d41f8e0cc6ed204543909849","title":"基于容器（docker）的 WRF模式 简易快速部署方案","content":"\nEasy-WRF\n\n\n\n\n\n\n\n\nWRF（Weather Research and Forecasting Model）模式是由NCEP，NCAR等科研机构中心着手开发的一种统一的中尺度天气预报模式。WRF模式系统具有的可移植，易维护，可扩充，高效率，方便等特点，使其成为改进从云尺度到各种不同天气尺度的重要天气特征预报精度的工具。\n但是WRF模式的安装对于初学者来说有一定的困难，因此为了帮助初学者在电脑上快速部署安装WRF模式，就有了该项目，Easy-WRF。\n项目地址：GitHub: https://github.com/SWZ128/easy-wrf\n本项目是单节点建模运行的容器化WRF，主要用于教学和培训示例，本人不是气象相关专业，谬误在所难免，望海涵。\nFeatures\nWPS + WRF（version 3.7.1）\n简易部署（docker）\n优雅易用（Oh-my-zsh）\n精简小巧（镜像1.6GB左右）\n国内部署简易\n\nInstallation &amp; Usage方案1、使用 docker pull 拉取（推荐）确保已经安装docker，如果还没有，点击我\ndocker pull swz128&#x2F;easy-wrf\n\n检查镜像是否拉取成功\ndocker images\n\n得到类似下方的输出\nREPOSITORY        TAG       IMAGE ID       CREATED             SIZE\nswz128&#x2F;easy-wrf   latest    2c04b5c62a0b   About an hour ago   1.6GB\n\nrun\ndocker run -v 需要挂载的本地目录:容器中的目录 -it --name test_001 swz128&#x2F;easy-wrf\n\n例如这样（请将路径修改为自己的）\ndocker run -v &#x2F;Users&#x2F;mac&#x2F;wrf&#x2F;wrf-data:&#x2F;root&#x2F;wrf-data -it --name test_001 swz128&#x2F;easy-wrf\n\n现在就可以愉快地学习和使用了\n停止容器\ndocker stop test_001\n\n当退出并停止容器后，可以使用如下命令再次进入\ndocker start test_001\ndocker exec -it test_001 &#x2F;bin&#x2F;zsh\n\n方案2、使用 docker build将项目克隆到本地\ngit clone https:&#x2F;&#x2F;github.com&#x2F;swz128&#x2F;easy-wrf.git\ncd easy-wrf&#x2F;\n\nBuild\ndocker build -t esay-wrf .\n\nSupport\n官方文档\n官方GitHub\n气象家园论坛\n\nAcknowledgment\ncontainer-wrf\nWRF\nwrf-coop\nwrf-src\n\nLicenseMIT License\n版权声明\n作者：麟子\n地址：https://swz128.top/post/easy-wrf\n协议：CC BY-SA 4.0 欢迎转载，务必注明出处\n\n","slug":"easy-wrf","date":"2020-09-30T16:00:00.000Z","categories_index":"项目","tags_index":"docker,WRF模式,安装,easy-wrf","author_index":"麟子"},{"id":"17f5327947b1d53e6c1283a3094dcb3b","title":"Dart 语言简易入门","content":"Dart 学习总结本文大量学习借鉴了 「AWeiLoveAndroid」、 「name不是null」 与 「彡廿」 的博文和 「Flutter中文网」 的入门指南，在此表示感谢，被引用文章链接见文末\n1.变量可以用C\\C++风格的方式声明变量，如int, bool, String等，也可以用var或者dynamic来声明，Dart会自动推断类型。\n没有赋初值的变量都会有默认值null。\nfinal要求变量只能初始化一次，并不要求赋的值一定是编译时常量，可以是常量也可以不是。而const要求在声明时初始化，并且赋值必需为编译时常量。\nDart有如下几种内建的数据类型：\n\nnumbers (var, num, int, double)\nstrings (var, String)\nbooleans (var, bool)\nlists (或者是arrays)\nmaps (类似Python里的字典)\nrunes（UTF-32字符集的字符）\nsymbols\n\nmain() &#123;\n  &#x2F;&#x2F; numbers\n  var a &#x3D; 0;\n  int b &#x3D; 1;\n  double c &#x3D; 0.1;\n\n  &#x2F;&#x2F; strings\n  var s1 &#x3D; &#39;hello&#39;;\n  String s2 &#x3D; &quot;world&quot;;\n\n  &#x2F;&#x2F; booleans\n  var real &#x3D; true;\n  bool isReal &#x3D; false;\n\n  &#x2F;&#x2F; lists\n  var arr &#x3D; [1, 2, 3, 4, 5];\n  List&lt;String&gt; arr2 &#x3D; [&#39;hello&#39;, &#39;world&#39;, &quot;123&quot;, &quot;456&quot;];\n  List&lt;dynamic&gt; arr3 &#x3D; [1, true, &#39;haha&#39;, 1.0];\n\n  &#x2F;&#x2F; maps\n  var map &#x3D; new Map();\n  map[&#39;name&#39;] &#x3D; &#39;zhangsan&#39;;\n  map[&#39;age&#39;] &#x3D; 10;\n  Map m &#x3D; new Map();\n  m[&#39;a&#39;] &#x3D; &#39;a&#39;;\n\n  &#x2F;&#x2F;runes，Dart 中 使用runes 来获取UTF-32字符集的字符。String的 codeUnitAt and codeUnit属性可以获取UTF-16字符集的字符\n  var clapping &#x3D; &#39;\\u&#123;1f44f&#125;&#39;;\n  print(clapping); &#x2F;&#x2F; 打印的是拍手emoji的表情\n\n  &#x2F;&#x2F; symbols\n  print(#s &#x3D;&#x3D; new Symbol(&quot;s&quot;)); &#x2F;&#x2F; true\n&#125;\n\n函数函数返回值所有的函数都有返回值，如果没有指定return语句，那么该函数的返回值为null。\nDart是一个面向对象的编程语言，所以即使是函数也是一个对象，也有一种类型Function，这就意味着函数可以赋值给某个变量或者作为参数传给另外的函数。虽然Dart推荐你给函数加上返回值，但是不加返回值的函数同样可以正常工作，另外你还可以用 =&gt; 代替 return 语句，比如下面的代码：\n&#x2F;&#x2F; 声明返回值\nint add(int a, int b) &#123;\n  return a + b;\n&#125;\n\n&#x2F;&#x2F; 不声明返回值\nadd2(int a, int b) &#123;\n  return a + b;\n&#125;\n\n&#x2F;&#x2F; &#x3D;&gt;是return语句的简写\nadd3(a, b) &#x3D;&gt; a + b;\n\nmain() &#123;\n  print(add(1, 2)); &#x2F;&#x2F; 3\n  print(add2(2, 3)); &#x2F;&#x2F; 5\n  print(add3(1, 2)); &#x2F;&#x2F; 3\n&#125;\n\n可选的命名参数sayHello(String name) &#123;\n  print(&quot;hello, my name is $name&quot;);\n&#125;\nsayHello2(&#123;String name&#125;) &#123;\n  print(&quot;hello, myname is $name&quot;);\n&#125;\n\nsayHello3(&#123;name: String&#125;) &#123;\n  print(&quot;hello, my name is $name&quot;);\n&#125;\n\nmain() &#123;\n  &#x2F;&#x2F; 打印 hello, my name is zhangsan\n  sayHello(&#39;zhangsan&#39;);\n\n  &#x2F;&#x2F; 打印 hello, my name is wangwu\n  sayHello2(name: &#39;wangwu&#39;);\n\n  sayHello3(name: &#39;wangwu&#39;);\n&#125;\n\n\n可以看到，定义命名参数时，你可以以 {type paramName} 或者 {paramName: type} 两种方式声明参数，而调用命名参数时，需要以 funcName(paramName: paramValue) 的形式调用。\n命名参数的参数并不是必须的，所以上面的代码中，如果调用 sayHello() 不带任何参数，也是可以的，只不过最后打印出来的结果是：hello, my name is null，在Flutter开发中，你可以使用 @required 注解来标识一个命名参数，这代表该参数是必须的，你不传则会报错，比如下面的代码：\nconst Scrollbar(&#123;Key key, @required Widget child&#125;)\n\n可选的位置参数使用中括号 [] 括起来的参数是函数的位置参数，代表该参数可传可不传，位置参数只能放在函数的参数列表的最后面，如下代码所示：\nsayHello(String name, int age, [String hobby]) &#123; &#x2F;&#x2F; 位置参数可以有多个，比如[String a, int b]\n  StringBuffer sb &#x3D; new StringBuffer();\n  sb.write(&quot;hello, this is $name and I am $age years old&quot;);\n  if (hobby !&#x3D; null) &#123;\n    sb.write(&quot;, my hobby is $hobby&quot;);\n  &#125;\n  print(sb.toString());\n&#125;\n\nmain() &#123;\n  &#x2F;&#x2F; hello, this is zhangsan and I am 20 years old\n  sayHello(&quot;zhangsan&quot;, 20);\n  &#x2F;&#x2F; hello, this is zhangsan and I am 20 years old, my hobby is play football\n  sayHello(&quot;zhangsan&quot;, 20, &quot;play football&quot;);\n&#125;\n\n注意，不能同时使用可选的位置参数和可选的命名参数。\n参数默认值&#x2F;&#x2F; 命名参数的默认值\nint add(&#123;int a, int b &#x3D; 3&#125;) &#123; &#x2F;&#x2F; 不能写成：int add(&#123;a: int, b: int &#x3D; 3&#125;)\n    return a + b;\n&#125;\n\n&#x2F;&#x2F; 位置参数的默认值\nint sum(int a, int b, [int c &#x3D; 3]) &#123;\n  return a + b + c;\n&#125;\n\nmain() &#123;\n  print(add(a: 1)); &#x2F;&#x2F;4\n  print(sum(1,2)); &#x2F;&#x2F;6\n&#125;\n\n函数作为变量var say &#x3D; (str)&#123;\n  print(str);\n&#125;;\n\nmain()&#123;\n  say(&quot;hi world&quot;);\n&#125;\n\n函数作为参数传递List list &#x3D; [10, 7, 23];\nlist.forEach((item) &#123;\n  print(&#39;$item&#39;);\n&#125;);\n这里面的参数是一个函数 (){} (省略函数名)。forEach 源码是：forEach (void f(E element)),它的参数是一个函数。以上语句可以简写成：\nlist.forEach((item) &#x3D;&gt; print(&#39;$item&#39;));\n\nvoid execute(var callback) &#123;\n    callback();\n&#125;\nmain() &#123;\n  execute(() &#x3D;&gt; print(&quot;xxx&quot;)); &#x2F;&#x2F;xxx\n&#125;\n\n\n函数别名typedef,会保留类型信息。\n以下代码，它不使用typedef：我们可以看到funs是一个函数，它是Function类型。\nclass Demo &#123;\n  Function funs;\n  Demo (int f(Object a, Object b)) &#123;\n    funs &#x3D; f;\n  &#125;\n&#125;\n\nint test(Object a, Object b) &#x3D;&gt; 0;\n\nvoid main() &#123;\n  Demo demo &#x3D; Demo(test);\n  &#x2F;&#x2F; funs是一个函数，但它是哪一种类型的函数?\n  print(demo.funs is Function); &#x2F;&#x2F; true\n&#125;\n\n可以使用typedef给函数取个别名。接下来使用typedef改造一下。\n1.给Function取一个别名叫做TypedefFuns\ntypedef TypedefFuns &#x3D; int Function(Object a, Object b);\n\n2.Demo类里的构造方法使用这个别名\nclass Demo &#123;\n  TypedefFuns funs;\n  Demo(this.funs);\n&#125;\n\n3.使用Demo类，传入一个函数。这里给Demo类传入了一个函数test。判断demo.funs属于哪一种类型。\nint test(Object a, Object b) &#x3D;&gt; 0;\n\nvoid main() &#123;\n  Demo demo &#x3D; Demo(test);\n  print(demo.funs is Function); &#x2F;&#x2F; true\n  print(demo.funs is Demo); &#x2F;&#x2F; false\n&#125;\ntypedef还可以这样使用\ntypedef TypedefFuns2&lt;T&gt; &#x3D; int Function(T a, T b);\nint test2(int a, int b) &#x3D;&gt; a - b;\nvoid main() &#123;\n  print(test2 is TypedefFuns2&lt;int&gt;); &#x2F;&#x2F; True\n&#125;\n\n运算符运算符main() &#123;\n  &#x2F;&#x2F; 与Java相同的运算符操作\n\n  int a &#x3D; 1;\n  ++a;\n  a++;\n  var b &#x3D; 1;\n  print(a &#x3D;&#x3D; b);  &#x2F;&#x2F; false\n  print(a * b); &#x2F;&#x2F; 3\n  bool real &#x3D; false;\n  real ? print(&#39;real&#39;) : print(&#39;not real&#39;); &#x2F;&#x2F; not real\n  print(real &amp;&amp; a &#x3D;&#x3D; b); &#x2F;&#x2F; false\n  print(real || a &#x3D;&#x3D; 3); &#x2F;&#x2F; true\n  print(a !&#x3D; 2); &#x2F;&#x2F; true\n  print(a &lt;&#x3D; b); &#x2F;&#x2F; false\n  var c &#x3D; 9;\n  c +&#x3D; 10;\n  print(&quot;c &#x3D; $c&quot;); &#x2F;&#x2F; c &#x3D; 19\n  print(1&lt;&lt;2); &#x2F;&#x2F; 4\n\n  &#x2F;&#x2F; 与Java不太一样的运算符操作\n\n  &#x2F;&#x2F; is运算符用于判断一个变量是不是某个类型的数据\n  &#x2F;&#x2F; is!则是判断变量不是某个类型的数据\n  var s &#x3D; &quot;hello&quot;;\n  print(s is String); &#x2F;&#x2F; true\n  var num &#x3D; 6;\n  print(num is! String); &#x2F;&#x2F; true\n\n  &#x2F;&#x2F; ~&#x2F;才是取整运算符，如果使用&#x2F;则是除法运算，不取整\n  int k &#x3D; 1;\n  int j &#x3D; 2;\n  print(k &#x2F; j); &#x2F;&#x2F; 0.5\n  print(k ~&#x2F; j); &#x2F;&#x2F; 0\n\n  &#x2F;&#x2F; as运算符类似于Java中的cast操作，将一个对象强制类型转换\n  (emp as Person).teach();\n\n  &#x2F;&#x2F; ??&#x3D;运算符 如果 ??&#x3D; 运算符前面的变量为null，则赋值，否则不赋值\n  var param1 &#x3D; &quot;hello&quot;, param2 &#x3D; null;\n  param1 ??&#x3D; &quot;world&quot;;\n  param2 ??&#x3D; &quot;world&quot;;\n  print(&quot;param1 &#x3D; $param1&quot;); &#x2F;&#x2F; param1 &#x3D; hello\n  print(&quot;param2 &#x3D; $param2&quot;); &#x2F;&#x2F; param2 &#x3D; world\n  \n  &#x2F;&#x2F; ?.运算符\n  var str1 &#x3D; &quot;hello world&quot;;\n  var str2 &#x3D; null;\n  print(str1?.length); &#x2F;&#x2F; 11\n  print(str2?.length); &#x2F;&#x2F; null \n  print(str2.length); &#x2F;&#x2F; 报错\n&#125;\n\n..运算符（级联操作）class Person &#123;\n  eat() &#123;\n    print(&quot;I am eating...&quot;);\n  &#125;\n\n  sleep() &#123;\n    print(&quot;I am sleeping...&quot;);\n  &#125;\n\n  study() &#123;\n    print(&quot;I am studying...&quot;);\n  &#125;\n&#125;\n\nmain() &#123;\n  &#x2F;&#x2F; 依次打印\n  &#x2F;&#x2F;  I am eating...\n  &#x2F;&#x2F;  I am sleeping...\n  &#x2F;&#x2F;  I am studying...\n  new Person()..eat()\n      ..sleep()\n      ..study();\n&#125;\n\n可以看到，使用..调用某个对象的方法（或者成员变量）时，返回值是这个对象本身，所以你可以接着使用..调用这个对象的其他方法，这不就类似于Java中的建造者模式，每次build某个属性时，都返回一个this对象。\n流程控制常规main() &#123;\n  &#x2F;&#x2F; if else语句\n  int score &#x3D; 80;\n  if (score &lt; 60) &#123;\n    print(&quot;so bad!&quot;);\n  &#125; else if (score &gt;&#x3D; 60 &amp;&amp; score &lt; 80) &#123;\n    print(&quot;just so so!&quot;);\n  &#125; else if (score &gt;&#x3D; 80) &#123;\n    print(&quot;good job!&quot;);\n  &#125;\n\n  &#x2F;&#x2F; switch语句\n  String a &#x3D; &quot;hello&quot;;\n  &#x2F;&#x2F; case语句中的数据类型必须是跟switch中的类型一致\n  switch (a) &#123;\n    case &quot;hello&quot;:\n      print(&quot;haha&quot;);\n      break;\n    case &quot;world&quot;:\n      print(&quot;heihei&quot;);\n      break;\n    default:\n      print(&quot;WTF&quot;);\n  &#125;\n\n  &#x2F;&#x2F; for语句\n  List&lt;String&gt; list &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\n  for (int i &#x3D; 0; i &lt; list.length; i++) &#123;\n    print(list[i]);\n  &#125;\n  for (var i in list) &#123;\n    print(i);\n  &#125;\n  &#x2F;&#x2F; 这里的箭头函数参数必须用圆括号扩起来\n  list.forEach((item) &#x3D;&gt; print(item)); &#x2F;&#x2F;匿名函数\n\n  &#x2F;&#x2F; while语句\n  int start &#x3D; 1;\n  int sum &#x3D; 0;\n  while (start &lt;&#x3D; 100) &#123;\n    sum +&#x3D; start;\n    start++;\n  &#125;\n  print(sum);\n\n  &#x2F;&#x2F; try catch语句\n  try &#123;\n    print(1 ~&#x2F; 0);\n  &#125; catch (e) &#123;\n    &#x2F;&#x2F; IntegerDivisionByZeroException\n    print(e);\n  &#125;\n  try &#123;\n    1 ~&#x2F; 0;\n  &#125; on IntegerDivisionByZeroException &#123; &#x2F;&#x2F; 捕获指定类型的异常\n    print(&quot;error&quot;); &#x2F;&#x2F; 打印出error\n  &#125; finally &#123;\n    print(&quot;over&quot;); &#x2F;&#x2F; 打印出over\n  &#125;\n&#125;\n\nassert（断言）断言的作用是：如果表达式的求值结果不满足需要，则打断代码的执行。可以要将提示消息附加到断言，添加一个字符串作为第二个参数。\nvoid main()\n&#123;\n    String urlString &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#39;;\n    assert(urlString.startsWith(&#39;https&#39;), &#39;URL ($urlString) should start with &quot;https&quot;.&#39;);\n    &#x2F;&#x2F; Failed assertion: &#39;urlString.startsWith(&#39;https&#39;)&#39;: URL (http:&#x2F;&#x2F;www.baidu.com) should start with &quot;https&quot;\n    &#x2F;&#x2F; 当urlString不是以https开头时，代码的执行会被打断\n    &#x2F;&#x2F; 当urlString是以https开头时，代码会继续执行\n&#125;\n\n传入assert的参数，可以是任意表达式或者方法，只要返回值是bool就可以，当断言失败时（返回false），会抛出AssertionError异常。\n注意:断言只有在检查模式下运行有效，在生产模式下是不会运行的。\n类（Class）类的定义与构造方法Dart中的类没有访问控制，所以你不需要用private, protected, public等修饰成员变量或成员函数，一个简单的类如下代码所示：\nclass Person &#123;\n  String name;\n  int age;\n  String gender;\n  Person(this.name, this.age, this.gender);\n  sayHello() &#123;\n    print(&quot;hello, this is $name, I am $age years old, I am a $gender&quot;);\n  &#125;\n&#125;\n\n上面的Person类中有3个成员变量，一个构造方法和一个成员方法，看起来比较奇怪的是Person的构造方法，里面传入的3个参数都是this.xxx，而且没有大括号**{}**包裹的方法体，这种语法是Dart比较独特而简洁的构造方法声明方式，它等同于下面的代码：\nPerson(String name, int age, String gender) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n    this.gender &#x3D; gender;\n&#125;\n\n要调用Person类的成员变量或成员方法，可以用下面的代码。\nvar p &#x3D; new Person(&quot;zhangsan&quot;, 20, &quot;male&quot;);\np.sayHello(); &#x2F;&#x2F; hello, this is zhangsan, I am 20 years old, I am a male\np.age &#x3D; 50;\np.gender &#x3D; &quot;female&quot;;\np.sayHello(); &#x2F;&#x2F; hello, this is zhangsan, I am 50 years old, I am a female\n\n类除了有跟类名相同的构造方法外，还可以添加命名的构造方法，如下代码所示：\nclass Point &#123;\n  num x, y;区块中使用列表实例如下\n  Point(this.x, this.y);\n  &#x2F;&#x2F; 类的命名构造方法\n  Point.origin() &#123;\n    x &#x3D; 0;\n    y &#x3D; 0;\n  &#125;\n&#125;\n\nmain() &#123;\n  &#x2F;&#x2F; 调用Point类的命名构造方法origin()\n  var p &#x3D; new Point.origin();\n  var p2 &#x3D; new Point(1, 2);\n&#125;\n\n初始化列表类似C/C++风格的初始化列表。\nclass Test1 &#123;\n  var x, y;\n  Test1(var x, var y) : x &#x3D; x, y &#x3D; y &#123;\n    print(&#39;Test1 有参构造初始化&#39;);\n  &#125;\n&#125;\n\n在实际应用开发中，可以使用assert（断言）在初始化列表用来校验输入参数。\nclass Test1 &#123;\n  var x, y;\n\n  Test1(var x, var y) : assert(x &gt;&#x3D; 0) &#123;\n    print(&#39;Test1(): ($x, $y)&#39;);\n  &#125;\n&#125;\n\nassert（断言）的作用：如果表达式求值不满足需要，则打断代码的执行。\n类的继承Dart中使用 extends 关键字做类的继承，如果一个类只有命名的构造方法，在继承时需要注意，如下代码：\nclass Human &#123;\n  String name;\n  Human.fromJson(Map data) &#123;\n    print(&quot;Human&#39;s fromJson constructor&quot;);\n  &#125;\n&#125;\n\nclass Man extends Human &#123;\n  Man.fromJson(Map data) : super.fromJson(data) &#123;\n    print(&quot;Man&#39;s fromJson constructor&quot;);\n  &#125;\n&#125;\n\n由于Human类没有默认构造方法，只有一个命名构造方法fromJson，所以在Man类继承Human类时，需要调用父类的fromJson方法做初始化，而且必须使用 Man.fromJson(Map data) : super.fromJson(data) 这种写法，而不是像Java那样将 super （指向父类）写到花括号中。\n使用 @override 注解声明你要重写的函数，在这个函数内部可以使用 super 调用重写的这个父类的函数。实现如下：\nclass Test &#123;\n  void test() &#123;&#x2F;*这里省略方法内部的逻辑操作*&#x2F;&#125;\n  &#x2F;&#x2F; 其他逻辑\n&#125;\n\nclass TestChild extends Test &#123;\n  @override  &#x2F;&#x2F;@override标注在test()函数上面 表示test()函数是重写父类的。\n    void test() &#123;\n      super.test();&#x2F;&#x2F; 调用父类的test()函数\n      &#x2F;*这里省略方法内部的逻辑操作*&#x2F;\n    &#125;\n    &#x2F;&#x2F; 其他逻辑\n&#125;\n\n类的成员方法一个类的成员方法是一个函数，为这个类提供某些行为。上面的代码中已经有了一些类的成员方法的定义，这些定义方式跟Java很类似，你可以为某个类的成员变量提供getter/setter方法，如下代码：\nclass Rectangle &#123;\n  num left, top, width, height;\n\n  &#x2F;&#x2F; 构造方法传入left, top, width, height几个参数\n  Rectangle(this.left, this.top, this.width, this.height);\n\n  &#x2F;&#x2F; right, bottom两个成员变量提供getter&#x2F;setter方法\n  num get right &#x3D;&gt; left + width;\n  set right(num value) &#x3D;&gt; left &#x3D; value - width;\n  num get bottom &#x3D;&gt; top + height;\n  set bottom(num value) &#x3D;&gt; top &#x3D; value - height;\n&#125;\ngetter和setter是提供对象属性的读写访问的特殊方法。所有实例变量都生成一个隐式getter方法。非final实例变量也会生成隐式setter方法。使用get和set关键字通过实现getter和setter来创建其他属性。\n静态方法静态方法：使用static关键字修饰的方法，也叫类方法，它不对实例进行操作，因此无权访问this。\n抽象类和抽象方法使用abstract修饰一个类，则这个类是抽象类，抽象类中可以有抽象方法和非抽象方法，抽象方法没有方法体，需要子类去实现，如下代码：\nabstract class Doer &#123;\n  &#x2F;&#x2F; 抽象方法，没有方法体，需要子类去实现\n  void doSomething();\n  &#x2F;&#x2F; 普通的方法\n  void greet() &#123;\n    print(&quot;hello world!&quot;);\n  &#125;\n&#125;\n\nclass EffectiveDoer extends Doer &#123;\n  &#x2F;&#x2F; 实现了父类的抽象方法\n  void doSomething() &#123;\n    print(&quot;I&#39;m doing something...&quot;);\n  &#125;\n&#125;\n\n运算符重载Dart中有类似于C++中的运算符重载语法，比如下面的代码定义了一个向量类，重载了向量的+ -运算：\nclass Vector &#123;\n  num x, y;\n  Vector(this.x, this.y);\n  Vector operator +(Vector v) &#x3D;&gt; new Vector(x + v.x, y + v.y);\n  Vector operator -(Vector v) &#x3D;&gt; new Vector(x - v.x, y - v.y);\n  printVec() &#123;\n    print(&quot;x: $x, y: $y&quot;);\n  &#125;\n&#125;\n\nmain() &#123;\n  Vector v1 &#x3D; new Vector(1, 2);\n  Vector v2 &#x3D; new Vector(3, 4);\n  (v1 - v2).printVec(); &#x2F;&#x2F; -2, -2\n  (v1 + v2).printVec(); &#x2F;&#x2F; 4, 6\n&#125;\n注意：**!=**不是可重写的运算符。\n枚举类使用enum关键字声明枚举类型：\nenum Color &#123; red, green, blue &#125;\n\n枚举中的每个值都有一个index getter，它返回枚举声明中值的从零开始的位置。例如，第一个值具有索引0，第二个值具有索引1。\nassert(Color.red.index &#x3D;&#x3D; 0);\nassert(Color.green.index &#x3D;&#x3D; 1);\nassert(Color.blue.index &#x3D;&#x3D; 2);\n\n在实际应用开发中，可以使用assert在初始化列表用来校验输入参数。\n要获取枚举中所有值的列表，请使用枚举values常量。\nList&lt;Color&gt; colors &#x3D; Color.values;\nassert(colors[2] &#x3D;&#x3D; Color.blue);\n\n可以在 switch 语句中使用枚举，如果你不处理所有枚举值，你将收到警告。\nvar aColor &#x3D; Color.blue;\nswitch (aColor) &#123;\n  case Color.red:\n    print(&#39;Red&#39;);\n    break;\n  case Color.green:\n    print(&#39;Green&#39;);\n    break;\n  default: &#x2F;&#x2F; 你没有这个 你会看到一个警告\n    print(aColor); &#x2F;&#x2F; &#39;Color.blue&#39;\n&#125;\n静态成员变量和静态成员方法&#x2F;&#x2F; 类的静态成员变量和静态成员方法\nclass Cons &#123;\n  static const name &#x3D; &quot;zhangsan&quot;;\n  static sayHello() &#123;\n    print(&quot;hello, this is $&#123;Cons.name&#125;&quot;);\n  &#125;\n&#125;\n\nmain() &#123;\n  Cons.sayHello(); &#x2F;&#x2F; hello, this is zhangsan\n  print(Cons.name); &#x2F;&#x2F; zhangsan\n&#125;\n\nmixinsmixins是一个重复使用类中代码的方式，比如下面的代码：\nclass A &#123;\n  a() &#123;\n    print(&quot;A&#39;s a()&quot;);\n  &#125;\n&#125;\n\nclass B &#123;\n  b() &#123;\n    print(&quot;B&#39;s b()&quot;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用with关键字，表示类C是由类A和类B混合而构成\nclass C &#x3D; A with B;\n\nmain() &#123;\n  C c &#x3D; new C();\n  c.a(); &#x2F;&#x2F; A&#39;s a()\n  c.b(); &#x2F;&#x2F; B&#39;s b()\n&#125;\n\n泛型（Generics）正确指定泛型类型会产生更好的生成代码。泛型可以减小代码的复杂度。\nDart内置的数据类型List就是一个泛型数据类型，你可以往List中塞任何你想的数据类型比如整型、字符串、布尔值等。\n 当然，如果您希望列表只包含字符串，则可以将其声明为**List&lt;String&gt;**（字符串列表）。这样一来，工具可以检测到将非字符串分配给列表可能是一个错误。\nvar names &#x3D; List&lt;String&gt;();\nnames.addAll([&#39;Seth&#39;, &#39;Kathy&#39;, &#39;Lars&#39;]);\n&#x2F;&#x2F; 报错 The argument type &#39;int&#39; can&#39;t be assigned to the parameter type &#39;String&#39;.\nnames.add(42); \n\n泛型允许你在多种类型之间共享单个接口和实现，同时仍然利用静态分析。你可以创建一个带有类型参数的接口。示例如下：T是一个占位符，你可以将其视为开发人员稍后定义的类型。\nabstract class Cache&lt;T&gt; &#123;\n  T getByKey(String key);\n&#125;\n\nDart库（Libraries）Dart目前已经有很多的库提供给开发者，许多功能不需要开发者自己去实现，只需要导入对应的包即可，使用import语句来导入某个包，比如下面的代码：\nimport &#39;dart:html&#39;;\n\n如果你想导入自己写的某个代码文件，使用相对路径即可，例如当前有一个demo.dart文件，跟该文件同级目录下有个util.dart文件，文件代码如下：\n&#x2F;&#x2F; util.dart文件内容\n\nint add(int a, int b) &#123;\n  return a + b;\n&#125;\n\n在demo.dart文件中如果要引用util.dart文件，使用下面的方式导入：\n&#x2F;&#x2F; demo.dart\n\nimport &#39;.&#x2F;util.dart&#39;;\n\nmain() &#123;\n  print(add(1, 2));\n&#125;\n\n你可以使用as关键字为导入的某个包设置一个前缀，或者说别名，比如下面的代码：\nimport &#39;package:lib1&#x2F;lib1.dart&#39;;\nimport &#39;package:lib2&#x2F;lib2.dart&#39; as lib2;\n\n&#x2F;&#x2F; Uses Element from lib1.\nElement element1 &#x3D; Element();\n\n&#x2F;&#x2F; Uses Element from lib2.\nlib2.Element element2 &#x3D; lib2.Element();\n\n你也可以在导入包时使用show, hide关键字来导入某个包中的部分功能，比如下面的代码：\n&#x2F;&#x2F; 只导入foo\nimport &#39;package:lib1&#x2F;lib1.dart&#39; show foo;\n\n&#x2F;&#x2F; 导入除了foo的所有其他部分\nimport &#39;package:lib2&#x2F;lib2.dart&#39; hide foo;\n\n导入包时使用deferred as可以让这个包懒加载，懒加载的包只会在该包被使用时得到加载，而不是一开始就加载，比如下面的代码：\nimport &#39;package:greetings&#x2F;hello.dart&#39; deferred as hello;\n\n异步支持Dart类库有非常多的返回Future或者Stream对象的函数。 这些函数被称为异步函数：它们只会在设置好一些耗时操作之后返回，比如像 IO操作。而不是等到这个操作完成。\nasync和await关键词支持了异步编程，允许您写出和同步代码很像的异步代码。\nFutureFuture与JavaScript中的Promise非常相似，表示一个异步操作的最终完成（或失败）及其结果值的表示。简单来说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。一个Future只会对应一个结果，要么成功，要么失败。\n由于本身功能较多，这里我们只介绍其常用的API及特性。还有，请记住，Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用。\nFuture.then为了方便示例，在本例中我们使用Future.delayed创建了一个延时任务（实际场景会是一个真正的耗时任务，比如一次网络请求），即2秒后返回结果字符串”hi world!”，然后我们在then中接收异步结果并打印结果，代码如下：\nmain() &#123;\n  Future.delayed(new Duration(seconds: 2),()&#123;\n    return &quot;hi world!&quot;;\n  &#125;).then((data)&#123;\n    print(data);\n  &#125;);\n&#125;\n\nFuture.catchError如果异步任务发生错误，我们可以在catchError中捕获错误，我们将上面示例改为：\nmain() &#123;\n  Future.delayed(new Duration(seconds: 2),()&#123;\n    &#x2F;&#x2F;return &quot;hi world!&quot;;\n    throw AssertionError(&quot;Error&quot;);\n  &#125;).then((data)&#123;\n    &#x2F;&#x2F;执行成功会走到这里\n    print(&quot;success&quot;);\n  &#125;).catchError((e)&#123;\n    &#x2F;&#x2F;执行失败会走到这里\n    print(e);\n  &#125;);\n&#125;\n\n在本示例中，我们在异步任务中抛出了一个异常，then的回调函数将不会被执行，取而代之的是catchError回调函数将被调用；但是，并不是只有catchError回调才能捕获错误，then方法还有一个可选参数onError，我们也可以它来捕获异常：\nmain() &#123;\n  Future.delayed(new Duration(seconds: 2), () &#123;\n      &#x2F;&#x2F;return &quot;hi world!&quot;;\n      throw AssertionError(&quot;Error&quot;);\n  &#125;).then((data) &#123;\n      print(&quot;success&quot;);\n  &#125;, onError: (e) &#123;\n      print(e);\n  &#125;);\n&#125;\n\nFuture.whenComplete有些时候，我们会遇到无论异步任务执行成功或失败都需要做一些事的场景，比如在网络请求前弹出加载对话框，在请求结束后关闭对话框。这种场景，有两种方法，第一种是分别在then或catch中关闭一下对话框，第二种就是使用Future的whenComplete回调，我们将上面示例改一下：\nmain() &#123;\n  Future.delayed(new Duration(seconds: 2),()&#123;\n    &#x2F;&#x2F;return &quot;hi world!&quot;;\n    throw AssertionError(&quot;Error&quot;);\n  &#125;).then((data)&#123;\n    &#x2F;&#x2F;执行成功会走到这里\n    print(data);\n  &#125;).catchError((e)&#123;\n    &#x2F;&#x2F;执行失败会走到这里\n    print(e);\n  &#125;).whenComplete(()&#123;\n    &#x2F;&#x2F;无论成功或失败都会走到这里\n  &#125;);\n&#125;\n\nFuture.wait有些时候，我们需要等待多个异步任务都执行结束后才进行一些操作，比如我们有一个界面，需要先分别从两个网络接口获取数据，获取成功后，我们需要将两个接口数据进行特定的处理后再显示到UI界面上，应该怎么做？答案是Future.wait，它接受一个Future数组参数，只有数组中所有Future都执行成功后，才会触发then的成功回调，只要有一个Future执行失败，就会触发错误回调。下面，我们通过模拟Future.delayed来模拟两个数据获取的异步任务，等两个异步任务都执行成功时，将两个异步任务的结果拼接打印出来，代码如下：\nmain() &#123;\n  Future.wait([\n    &#x2F;&#x2F; 2秒后返回结果\n    Future.delayed(new Duration(seconds: 2), () &#123;\n        return &quot;hello&quot;;\n      &#125;),\n    &#x2F;&#x2F; 4秒后返回结果\n    Future.delayed(new Duration(seconds: 4), () &#123;\n        return &quot; world&quot;;\n      &#125;)\n  ]).then((results)&#123;\n    print(results[0]+results[1]);\n  &#125;).catchError((e)&#123;\n    print(e);\n  &#125;);\n&#125;\n\n执行上面代码，4秒后你会在控制台中看到“hello world”。\nasync/awaitDart中的async/await和JavaScript中的async/await功能和用法是一模一样的。\n回调地狱(Callback Hell)如果代码中有大量异步逻辑，并且出现大量异步任务依赖其它异步任务的结果时，必然会出现Future.then回调中套回调情况。举个例子，比如现在有个需求场景是用户先登录，登录成功后会获得用户ID，然后通过用户ID，再去请求用户个人信息，获取到用户个人信息后，为了使用方便，我们需要将其缓存在本地文件系统，代码如下：\n&#x2F;&#x2F;先分别定义各个异步任务\nFuture&lt;String&gt; login(String userName, String pwd)&#123;\n    ...\n    &#x2F;&#x2F;用户登录\n&#125;;\nFuture&lt;String&gt; getUserInfo(String id)&#123;\n    ...\n    &#x2F;&#x2F;获取用户信息\n&#125;;\nFuture saveUserInfo(String userInfo)&#123;\n    ...\n    &#x2F;&#x2F; 保存用户信息\n&#125;;\n\n接下来，执行整个任务流：\nlogin(&quot;alice&quot;,&quot;******&quot;).then((id)&#123;\n  &#x2F;&#x2F;登录成功后通过，id获取用户信息\n  getUserInfo(id).then((userInfo)&#123;\n    &#x2F;&#x2F;获取用户信息后保存\n    saveUserInfo(userInfo).then(()&#123;\n       &#x2F;&#x2F;保存用户信息，接下来执行其它操作\n        ...\n    &#125;);\n  &#125;);\n&#125;)\n\n可以感受一下，如果业务逻辑中有大量异步依赖的情况，将会出现上面这种在回调里面套回调的情况，过多的嵌套会导致的代码可读性下降以及出错率提高，并且非常难维护，这个问题被形象的称为回调地狱（Callback Hell）。回调地狱问题在之前JavaScript中非常突出，也是JavaScript被吐槽最多的点，但随着ECMAScript6和ECMAScript7标准发布后，这个问题得到了非常好的解决，而解决回调地狱的两大神器正是ECMAScript6引入了Promise，以及ECMAScript7中引入的async/await。 而在Dart中几乎是完全平移了JavaScript中的这两者：Future相当于Promise，而async/await连名字都没改。接下来我们看看通过Future和async/await如何消除上面示例中的嵌套问题。\n使用Future消除Callback Helllogin(&quot;alice&quot;,&quot;******&quot;).then((id)&#123;\n      return getUserInfo(id);\n&#125;).then((userInfo)&#123;\n    return saveUserInfo(userInfo);\n&#125;).then((e)&#123;\n  &#x2F;&#x2F;执行接下来的操\n&#125;).catchError((e)&#123;\n  &#x2F;&#x2F;错误处理\n  print(e);\n&#125;);\n\n正如上文所述， “Future的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用”，如果在then中返回的是一个Future的话，该Future会执行，执行结束后会触发后面的then回调，这样依次向下，就避免了层层嵌套。\n使用async/await消除callback hell通过Future回调中再返回Future的方式虽然能避免层层嵌套，但是还是有一层回调，有没有一种方式能够让我们可以像写同步代码那样来执行异步任务而不使用回调的方式？答案是肯定的，这就要使用async/await了，下面我们先直接看代码，然后再解释，代码如下：\ntask() async &#123;\n  try&#123;\n    String id &#x3D; await login(&quot;alice&quot;,&quot;******&quot;);\n    String userInfo &#x3D; await getUserInfo(id);\n    await saveUserInfo(userInfo);\n    &#x2F;&#x2F;执行接下来的操作\n  &#125; catch(e)&#123;\n    &#x2F;&#x2F;错误处理\n    print(e);\n  &#125;\n&#125;\n\n\nasync用来表示函数是异步的，定义的函数会返回一个Future对象，可以使用then方法添加回调函数。\nawait后面是一个Future，表示等待该异步任务完成，异步完成后才会往下走；await必须出现在async函数内部。\n\n可以看到，我们通过async/await将一个异步流用同步的代码表示出来了。\n\n\n\n\n\n\n\n\n\n其实，无论是在JavaScript还是Dart中，async/await都只是一个语法糖，编译器或解释器最终都会将其转化为一个Promise（Future）的调用链。\nStreamStream也是用于接收异步事件数据，和Future不同的是，它可以接收多个异步操作的结果（成功或失败）。 也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 Stream 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子：\nmain() &#123;\n  Stream.fromFutures([\n    &#x2F;&#x2F; 1秒后返回结果\n    Future.delayed(new Duration(seconds: 1), () &#123;\n        return &quot;hello 1&quot;;\n      &#125;),\n    &#x2F;&#x2F; 抛出一个异常\n    Future.delayed(new Duration(seconds: 2),()&#123;\n        throw AssertionError(&quot;Error&quot;);\n      &#125;),\n    &#x2F;&#x2F; 3秒后返回结果\n    Future.delayed(new Duration(seconds: 3), () &#123;\n        return &quot;hello 3&quot;;\n      &#125;)\n  ]).listen((data)&#123;\n    print(data);\n  &#125;, onError: (e)&#123;\n    print(e.message);\n  &#125;,onDone: ()&#123;\n\n  &#125;);\n&#125;\n\n上面的代码依次会输出：\nI&#x2F;flutter (17666): hello 1\nI&#x2F;flutter (17666): Error\nI&#x2F;flutter (17666): hello 3\n\nDart和Java及JavaScript对比\n\n\n\n\n\n\n\n\n之所以将Dart与Java和JavaScript对比，是因为，这两者分别是强类型语言和弱类型语言的典型代表，并且Dart 语法中很多地方也都借鉴了Java和JavaScript。\nDart vs Java\n\n\n\n\n\n\n\n\n客观的来讲，Dart在语法层面确实比Java更有表现力；在VM层面，Dart VM在内存回收和吞吐量都进行了反复的优化，但具体的性能对比，笔者没有找到相关测试数据，但在笔者看来，只要Dart语言能流行，VM的性能就不用担心，毕竟Google在Go（没用VM但有GC）、JavaScript（v8）、Dalvik（Android上的Java VM）上已经有了很多技术积淀。值得注意的是Dart在Flutter中已经可以将GC做到10ms以内，所以Dart和Java相比，决胜因素并不会是在性能方面。而在语法层面，Dart要比Java更有表现力，最重要的是Dart对函数式编程支持要远强于Java(目前只停留在Lambda表达式)，而Dart目前真正的不足是生态，但笔者相信，随着Flutter的逐渐火热，会回过头来反推Dart生态加速发展，对于Dart来说，现在需要的是时间。\nDart vs JavaScript\n\n\n\n\n\n\n\n\nJavaScript的弱类型一直被抓短，所以TypeScript、CoffeeScript甚至是Facebook的flow（虽然并不能算JavaScript的一个超集，但也通过标注和打包工具提供了静态类型检查）才有市场。就笔者使用过的脚本语言中（笔者曾使用过Python、PHP），JavaScript无疑是动态化支持最好的脚本语言，比如在JavaScript中，可以给任何对象在任何时候动态扩展属性，对于精通JavaScript的高手来说，这无疑是一把利剑。但是，任何事物都有两面性，JavaScript的强大的动态化特性也是把双刃剑，你可经常听到另一个声音，认为JavaScript的这种动态性糟糕透了，太过灵活反而导致代码很难预期，无法限制不被期望的修改。毕竟有些人总是对自己或别人写的代码不放心，他们希望能够让代码变得可控，并期望有一套静态类型检查系统来帮助自己减少错误。正因如此，在Flutter中，Dart几乎放弃了脚本语言动态化的特性，如不支持反射、也不支持动态创建函数等。并且Dart在2.0强制开启了类型检查（Strong Mode），原先的检查模式（checked mode）和可选类型（optional type）将淡出，所以在类型安全这个层面来说，Dart和TypeScript、CoffeeScript是差不多的，所以单从这一点来看，Dart并不具备什么明显优势，但综合起来看，Dart既能进行服务端脚本、APP开发、web开发，这就有优势了！\n参考引用本文大量学习借鉴了以下文章\n《Dart的语法详解系列篇（二）– 类与函数》 作者：AWeiLoveAndroid 链接：https://www.jianshu.com/p/44ae73a58ebc\n《30分钟掌握Dart语言》 作者：彡廿 链接：https://www.jianshu.com/p/06aebcad0543\n《Dart语言简介》 出处 Flutter中文网 链接：https://book.flutterchina.club/chapter1/dart.html\n《Dart 断言(assert)和异常》 作者：name不是null 链接：https://www.jianshu.com/p/7c5c0a1f118a\n版权声明\n作者：麟子\n地址：https://swz128.top/post/Dart\n协议：CC BY-SA 4.0 欢迎转载，务必注明出处\n\n","slug":"Dart","date":"2019-12-31T16:00:00.000Z","categories_index":"教程","tags_index":"Dart,学习,教程","author_index":"麟子"},{"id":"a1a8603ea3ed2b561af50bfd8a1ae45f","title":"NCL(The NCAR Command Language)Linux,Windows多平台安装","content":"NCL(The NCAR Command Language)Linux,Windows多平台安装\n\n\n\n\n\n\n\n\nNCL(The NCAR Command Language)是一种专门为科学数据处理以及数据可视化设计的高级语言，很适合用在气象数据的处理和可视化上。–百度百科\n\nLinux下安装NCL官网：http://www.ncl.ucar.edu/进入到下载页面\n\nncl的官网提供了3种安装方式\n\nconda\n\n二进制安装包\n\n源码编译安装\n\n\n\n1.Conda方式安装NCLConda简介\n\n\n\n\n\n\n\n\nConda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和Windows，也可以打包和分发其他软件。\nConda的安装详见下面这个文章\n\n\n\n\n\n\n\n\n\n作者：卖萌哥链接：https://www.jianshu.com/p/edaa744ea47d\n安装ncl如果您已有conda，但已有一段时间未更新，则可能需要通过从UNIX终端窗口键入以下内容来更新它：\nconda update -n root --all\n\n然后安装ncl-stable软件包\nconda create -n ncl_stable -c conda-forge ncl\nsource activate ncl_stable\n\n安装完成！\n输入如下代码，检测安装结果：\nncl -V\nng4ex xy05n -clean -W png\n\n显示如下：\n\n2.二进制包安装在下载页面中\n\n点击里面的a list of binaries链接。进入到二进制安装包的下载页面\n\n在下载页面，提供了多个Linux平台的下载链接，比如常见的CentOS、Debian等，你根据自己使用的平台来选择。网站在国外，下载会很慢，请耐心等待。\n\n如果不介意版本新旧的话，可以在我分享的百度网盘链接下载：\n链接: https://pan.baidu.com/s/1wjMWLIdpPgUNmBt5O8RjHQ  密码: 3bi6\n如果链接挂掉，请务必邮件告知我。\n\n因为NCL是图形化编程，因此必须在Linux的图形桌面下安装。\n打开终端\nsudo mkdir &#x2F;usr&#x2F;local&#x2F;ncl-6.4.0 #以我分享的ncl版本为例\nsudo tar -xvf ～&#x2F;ncl_ncarg-6.4.0-CentOS7.3_64bit_gnu485.tar.gz -C &#x2F;usr&#x2F;local&#x2F;ncl-6.4.0\n#假设你的ncl包在用户目录下\n\n如果第一次执行的时候报错，提示缺少libgfortran.so.3这个库文件，我们来安装这个包。命令是：\nyum install libgfortran -y #以CentOS为例，其他平台类似，具体请自行百度\n\n如果有其他问题，请查阅http://www.ncl.ucar.edu/Download/linux.shtml\n为了更方便使用，我们将ncl的路径添加到系统路径中去\nvim ~&#x2F;.bashrc\n\n在结尾添加如下\nexport NCARG_ROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;ncl-6.4.0\nexport PATH&#x3D;$NCARG_ROOT&#x2F;bin:$PATH\n\n然后保存退出（:wq）。（vim是一款极其著名的命令行编辑器，其操作使用方法可以百度一下）\n然后执行命令：\nsource ~&#x2F;.bashrc\n\n测试一下：\nncl -V\n\n如果能正确显示NCL的版本号，说明安装完毕且正确。\n3.源码编译安装略略略，有时间再更新^_^\nWindows下安装在Windows下安装Ubuntu子系统安装 Windows 10 的 Linux 子系统组件顺序： -&gt; 系统设置 -&gt; 应用 -&gt; 右侧的程序和功能 -&gt; 启动或关闭windows功能 -&gt; 勾选适用于 Linux 的 Windows 子系统\n\n确定后，重启电脑，系统更新配置。\n\n重启后，打开 Windows 应用市场，输入 linux 搜索，选择你自己想要的系统版本，选择 Ubuntu\n然后点击启动，第一次会进行初始化安装。\n初始化安装完成，设置帐号密码，用户名我们直接使用 root ，然后设置下密码就搞定了（在Linux下输入密码是不会显示*的）\nwindows 的 CMD 不好用，推荐个很不错的替代软件 Cmder 。下载地址：http://cmder.net/\nUbuntu基础配置更换国内数据源\nsudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.backup\nsudo vim &#x2F;etc&#x2F;apt&#x2F;sources.list\n\n在vim中，按i进入输入模式\n我们使用清华的源\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释\ndeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse\n# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse\ndeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse\n# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse\ndeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse\n# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse\ndeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse\n# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse\n\n\n# 预发布软件源，不建议启用\n# deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse\n# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse\n\n将以上全复制进sources.list，按Esc退出到命令模式，保存退出（:wq）\n然后更新\nsudo apt-get update\n\n安装附加软件包接下来，我们需要安装一些ncl可能需要的包\nsudo apt-get install csh libfontconfig gfortran libgfortran3\nsudo apt-get install libxrender-dev libx11-dev libxrender1\nsudo apt-get install libssh2-1 libgomp1\nsudo apt-get install firefox imagemagick\n\nNCL需要图形界面，我们需要安装Xming来显示图形。Xming的下载链接 https://sourceforge.net/projects/xming/\n有时候Xming会出现问题，尽量在启动Ubuntu之前先启动Xming。\n如果你觉得Xming无法满足你，你可以参考这篇文章：https://blog.csdn.net/u011138447/article/details/78262369\n下载NCL你可以直接用命令下载到Ubuntu\nwget https:&#x2F;&#x2F;www.earthsystemgrid.org&#x2F;download&#x2F;fileDownload.html?logicalFileId&#x3D;246ab3ec-fa02-11e6-a976-00c0f03d5b7c\n\n或者，在/mnt/有c、d……之类的目录，其对应Windows的C盘、D盘…… 所以你可以将你之前下载好的包拷贝到Ubuntu的当前工作目录。\nsudo mkdir &#x2F;usr&#x2F;local&#x2F;ncl-6.6.2 #以6.6.2为例\nsudo tar -zxf ~&#x2F;ncl_ncarg-6.6.2-Debian7.11_64bit_gnu472.tar.gz -C &#x2F;usr&#x2F;local&#x2F;ncl-6.6.2\n#假设你的ncl包在你的用户目录下\n\n然后\nvim ~&#x2F;.bashrc\n\n在vim中，按i进入输入模式，在最后添加\nexport NCARG_ROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;ncl-6.6.2\nexport PATH&#x3D;$NCARG_ROOT&#x2F;bin:$PATH\nexport DISPLAY&#x3D;:0\n\n按Esc退出到命令模式，保存退出（:wq）。\n测试你的NCLncl -V\n\n如果输入ncl版本，例如“6.4.2”，说明安装成功。\n或者可以\ncp $NCARG_ROOT&#x2F;lib&#x2F;ncarg&#x2F;nclex&#x2F;xyplot&#x2F;xy04n.ncl .\nncl xy04n.ncl\n\n会输出一张图表\n一些可能的问题如果出显了一些错误，比如告诉你缺少了”libxxxx.so”这类的库，你可以用”sudo apt-get install xxxx”来安装缺少的库或者包。\n如果你看到了这样的错误：\nwarning:GKS:GOPWK: --X driver error: error opening display\n\n这可能是你没有设置DISPLAY的环境变量，或者设置错误，输入\nprintenv DISPLAY\n\n详情请看这篇文章：http://www.ncl.ucar.edu/Download/windows_linux_subsystem.shtml#SetDisplay\n如果你的问题还没有解决，也可以参考这篇文章：https://wenku.baidu.com/view/a5f722906e1aff00bed5b9f3f90f76c660374c61.html window10下Linux子系统 + NCL 安装记录\n虚拟机下安装Ubuntu来运行ncl在Windows下有两款常用的虚拟机软件，VMware和Oracle VM VirtualBox，其中VMware是付费软件，Oracle VM VirtualBox是一款多平台的开源免费软件。VMware附许可码：链接: https://pan.baidu.com/s/1eAApTcS-J-JY4MSApsHXcQ  密码: 25utOracle VM VirtualBox的官网下载链接： https://www.virtualbox.org/wiki/Downloads\n我们还需要Ubuntu系统镜像文件，考虑到国内的网络环境，我们选择在清华大学的开源软件镜像站下载：https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/eoan/ubuntu-19.10-desktop-amd64.iso\n你也可以在这 https://mirrors.tuna.tsinghua.edu.cn/# 找到最新版\n\nOracle VM VirtualBox我这里使用Oracle VM VirtualBox来介绍一下安装\n装好Oracle VM VirtualBox后\n\n新建\n\n尽量不要把安装文件夹放在C盘\n\n剩下的一路默认到底\n\n然后点启动：\n\n这时候会弹出一个对话窗，然后可以选择我下好的Ubuntu系统镜像\n\n\n然后选择中文\n\n安装Ubuntu\n\n如果网路状况不好，可以不选择“安装Ubuntu时下载更新”\n\n然后\n\n\n之后输入个人信息：用户名，口令等。单击“继续”，安装过程可能需要几十分钟，请耐心等待。\n配置启动Ubuntu，打开终端窗口\n一个要点是：命令，文件名要通过Tab补全，这样就会减少录入错误。\n介于国内网络环境，我们先把数据源更换为清华的开源软件镜像站\nsudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.backup\nsudo vim &#x2F;etc&#x2F;apt&#x2F;sources.list\n\n在vim中，按i进入输入模式（如果提示没有安装vim，可以使用nano来编辑，可以参考这篇文章：https://man.linuxde.net/nano）\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释\ndeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse\n# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse\ndeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse\n# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse\ndeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse\n# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse\ndeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse\n# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse\n\n按Esc退出到命令模式，保存退出（:wq）。\n通过\nsudo apt-get update;sudo apt-get upgrade\n\n来更新一下系统\n然后可以参考前面的  跳转 来完成配置和ncl安装。\nCygwin下运行ncl可以参考这个：https://blog.csdn.net/Vicky510475733/article/details/79101561\n参考Installing NCL with “conda” http://www.ncl.ucar.edu/Download/conda.shtml\nNCL在Linux安装教程 https://jingyan.baidu.com/article/ab69b2707beaea2ca7189ffc.html\nconda的安装与使用 https://www.jianshu.com/p/edaa744ea47d\n告别NCL 拥抱Python https://cloud.tencent.com/developer/article/1471168\nNCL 6.5.0 在Ubuntu 16.04下的安装 https://www.jianshu.com/p/ce680e7ec8ed\nRunning NCL under Linux systems http://www.ncl.ucar.edu/Download/linux.shtml\nInstalling and running NCL on Windows 10 Linux Bash shell http://www.ncl.ucar.edu/Download/windows_linux_subsystem.shtml\nWindows10安装Linux子系统Ubuntu https://blog.csdn.net/zhouzme/article/details/78780479\nWindows 10’s Bash shell can run graphical Linux applications with this trick https://www.pcworld.com/article/3055403/windows-10s-bash-shell-can-run-graphical-linux-applications-with-this-trick.html\nHow to Install and Use the Linux Bash Shell on Windows 10 https://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/\nwindows 10中的ubuntu子系统安装桌面环境的方法（How to install Ubuntu-desktop in windows 10 Subsystem for Linux） https://blog.csdn.net/u011138447/article/details/78262369\nwindow10下Linux子系统 + NCL 安装记录 https://wenku.baidu.com/view/a5f722906e1aff00bed5b9f3f90f76c660374c61.html\nSet DISPLAY environment variable http://www.ncl.ucar.edu/Download/windows_linux_subsystem.shtml#SetDisplay\nnano命令 https://man.linuxde.net/nano\n新手进行Cygwin/X(Windows)系统下安装使用NCL https://blog.csdn.net/Vicky510475733/article/details/79101561\n其他告别NCL 拥抱Python\n\n\n\n\n\n\n\n\n晴天一声雷，NCL官网发布重要通告，他们决定不再更新NCL转而向Python发展。WHAT???我刚把NCL用熟了你就跟我说这个。\n\n\n\n\n\n\n\n\n\n但做出这种选择确实也是有一定道理的，python在地球科学社区中的应用越来越广泛，很多优秀的团队还有大牛基于python开发出了不少地球科学相关的库。得益于这些优秀的库，近些年python在地球科学领域快速发展，并逐渐成为未来的趋势。现在python不但可以替代NCL而且还能提供很多NCL不具备的功能。\nNCL to Python\n\n\n\n\n\n\n\n\nNCL的功能在python中转为了PyNIO和PyNGL这两个库：1.PyNIO使用了NetCDF的接口用来读写各种类型的数据，包括NetCDF、GRIB、HDF等。2.PyNGL是一个可视化的库，里面的参数设置和NCL中的很相似。\n\n\n\n\n\n\n\n\n\n其实让大家从一门自己熟悉的语言转换到另一门语言的过程是很痛苦的，前期肯定是特别的不习惯，但只要熬过了短暂的过渡期后面很快就能适应过来。不过幸运的是NCL团队很贴心的给出了NCL向Python过渡的指导手册（NCL-to-Python Transition Guide），链接在文末。熟悉NCL的小伙伴借助官方的文档一定能很快的完成向python的过渡。\nNCL-to-Python Transition Guide (PDF) http://www.ncl.ucar.edu/Document/Manuals/NCL_to_Python/Transition_Guide_NCL_PyNGL.pdf\n版权声明\n作者：麟子\n地址：https://swz128.top/post/NCL\n协议：CC BY-SA 4.0 欢迎转载，务必注明出处\n\n","slug":"NCL","date":"2019-11-30T16:00:00.000Z","categories_index":"教程","tags_index":"NCL,Linux,Windows","author_index":"麟子"}]